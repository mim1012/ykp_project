# 25년1월정산 데이터 기반 웹 대시보드 ERP 시스템 설계 방안

**작성자**: Manus AI  
**작성일**: 2025년 8월 21일  
**문서 버전**: 1.0

## 목차

1. [개요](#개요)
2. [현재 데이터 구조 분석](#현재-데이터-구조-분석)
3. [데이터 모델링 및 관계 설계](#데이터-모델링-및-관계-설계)
4. [웹 대시보드 ERP 아키텍처](#웹-대시보드-erp-아키텍처)
5. [핵심 기능 및 화면 설계](#핵심-기능-및-화면-설계)
6. [기술 스택 및 구현 방안](#기술-스택-및-구현-방안)
7. [단계별 구현 로드맵](#단계별-구현-로드맵)
8. [결론 및 권장사항](#결론-및-권장사항)

---

## 개요

본 보고서는 25년1월정산.xlsx 파일을 기반으로 한 웹 대시보드 ERP 시스템 구축을 위한 종합적인 설계 방안을 제시합니다. 현재 엑셀 기반으로 관리되고 있는 통신사 대리점 정산 업무를 웹 기반 ERP 시스템으로 전환하여 업무 효율성을 극대화하고, 실시간 데이터 분석 및 의사결정 지원 기능을 제공하는 것이 목표입니다.

분석 대상 엑셀 파일은 총 3개의 시트로 구성되어 있으며, 각각 다음과 같은 역할을 담당합니다:

- **개통표**: 개별 판매 트랜잭션 데이터 관리 (약 1,000여 건의 개통 기록)
- **월마감정산**: 월별 재무 집계 및 현금 흐름 관리
- **대리점별정산금**: 대리점별 성과 분석 및 정산 관리

현재 시스템의 주요 특징은 복잡한 엑셀 공식을 통한 자동 계산, 시트 간 데이터 연동, 그리고 다층적인 집계 구조를 가지고 있다는 점입니다. 이러한 복잡성을 웹 기반 시스템으로 효과적으로 전환하기 위해서는 체계적인 데이터 모델링과 사용자 친화적인 인터페이스 설계가 필수적입니다.




## 현재 데이터 구조 분석

### 개통표 시트 분석

개통표는 본 ERP 시스템의 핵심 트랜잭션 데이터를 담고 있는 가장 중요한 시트입니다. 총 110개의 컬럼과 약 1,000여 개의 행으로 구성되어 있으며, 각 행은 하나의 개통 건을 나타냅니다.

**주요 데이터 카테고리:**

1. **기본 정보 필드**
   - 판매자, 대리점, 통신사, 개통방식, 모델명
   - 개통일, 일련번호, 휴대폰번호
   - 고객명, 생년월일

2. **금액 관련 필드**
   - 액면/셋팅가, 구두1, 구두2, 그레이드, 부가추가
   - 서류상현금개통, 유심비, 신규번이할인, 차감금액
   - 리베총계, 정산금, 부/소세

3. **계산 필드**
   - 현금받음, 페이백, 세전/세후 마진
   - 직원상담비, 메일접수비
   - 각종 인센티브 및 환수 금액

4. **메타 정보**
   - 메모장, 특이사항
   - 처리 상태, 확인 여부

**핵심 비즈니스 로직:**

개통표의 가장 중요한 특징은 복잡한 마진 계산 구조입니다. 각 개통 건에 대해 다음과 같은 계산 흐름을 가집니다:

```
리베총계 = 액면/셋팅가 + 구두1 + 구두2 + 그레이드 + 부가추가
정산금 = 리베총계 - 서류상현금개통 + 유심비 + 신규번이할인 + 차감금액
세금 = 정산금 × 13.3%
세전마진 = 정산금 - 세금 + 현금받음 + 페이백
세후마진 = 세금 + 세전마진
```

이러한 계산 구조는 통신사 대리점 업계의 복잡한 수수료 체계를 반영하고 있으며, 웹 시스템에서도 동일한 로직을 구현해야 합니다.

### 월마감정산 시트 분석

월마감정산 시트는 개통표의 데이터를 기반으로 한 월별 재무 요약 정보를 제공합니다. 이 시트는 경영진의 의사결정을 위한 핵심 지표들을 포함하고 있어 대시보드의 메인 화면에 표시될 가능성이 높습니다.

**주요 집계 항목:**

1. **매출 관련**
   - 대리점 총정산금: 개통표의 모든 정산금 합계
   - 총매출: 실제 발생한 총 매출액
   - 순매출: 총매출에서 지출을 뺀 순수 매출

2. **지출 관리**
   - 총지출: 직원급여, 운영비, 환수금 등의 합계
   - 직원기본급합계: 직원들의 기본급 총액
   - 환수금액합계: 각종 환수 처리된 금액

3. **현금 흐름**
   - 받은 총 현금 합계: 실제 현금으로 받은 금액
   - 고객페이백 합계: 고객에게 지급한 페이백 총액
   - 통장잔고: 현재 보유 현금
   - 월 마감시 입금 해야할 금액: 정산 후 입금 필요 금액

4. **수익성 분석**
   - 순수익: 순매출에서 점장급여를 뺀 최종 수익
   - 실제순수익: 모든 비용을 반영한 실제 수익

**시트 간 연동 공식:**

월마감정산 시트의 대부분 값들은 개통표 시트의 데이터를 참조하는 공식으로 구성되어 있습니다. 예를 들어:

- `=SUM(개통표!AJ4)`: 개통표의 특정 컬럼 합계
- `=개통표!V2`: 개통표의 특정 셀 값 참조
- `=SUM(개통표!AD4)`: 현금 관련 데이터 집계

이러한 연동 구조는 웹 시스템에서 데이터베이스 뷰(View)나 집계 테이블로 구현할 수 있습니다.

### 대리점별정산금 시트 분석

대리점별정산금 시트는 성과 관리 및 대리점별 비교 분석을 위한 데이터를 제공합니다. 총 11개의 대리점에 대한 개별 성과를 추적하고 있으며, 각 대리점의 기여도와 수익성을 평가할 수 있는 구조로 되어 있습니다.

**대리점 목록:**
이앤티, 앤투윈, 초시대, 아엠티, 에프지, 지티알, 어니언, 유안, 에스엔, 해피, 씨비즈

**주요 분석 지표:**

1. **판매 성과**
   - 개통수: 각 대리점별 총 개통 건수
   - 내 정산서: 자체 정산서 기준 정산금
   - 대리점 정산서: 대리점에서 제출한 정산금 (수기입력)

2. **차액 관리**
   - 차액금: 내 정산서와 대리점 정산서의 차이
   - 총차액금: 모든 대리점의 차액 합계

3. **수익성 평가**
   - 순매출: 월마감정산에서 가져온 전체 순매출
   - 진짜순수익: 차액을 반영한 최종 순수익

**동적 계산 공식:**

대리점별정산금 시트는 SUMPRODUCT와 COUNTIF 함수를 활용한 복잡한 집계 공식을 사용합니다:

```excel
=SUMPRODUCT(COUNTIF(개통표!B9:B1002,{"ENT","이앤티"}))
=SUMPRODUCT(SUMIF(개통표!B9:B1002,{"ENT","이앤티"},개통표!AC9:AC1002))
```

이러한 공식들은 개통표에서 특정 대리점의 데이터만을 필터링하여 집계하는 역할을 하며, 웹 시스템에서는 SQL의 GROUP BY 절이나 집계 함수로 구현할 수 있습니다.

### 데이터 품질 및 일관성 분석

현재 엑셀 시스템의 데이터 품질을 분석한 결과, 다음과 같은 특징을 발견했습니다:

**데이터 밀도:**
- 개통표: 약 60-70%의 셀에 데이터 존재
- 월마감정산: 약 34%의 데이터 밀도 (많은 빈 셀 존재)
- 대리점별정산금: 약 19%의 데이터 밀도

**데이터 타입 분포:**
- 텍스트 필드: 판매자명, 대리점명, 고객정보 등
- 숫자 필드: 각종 금액, 날짜, 전화번호 등
- 공식 필드: 자동 계산되는 마진, 세금, 집계 값들

**일관성 이슈:**
- 대리점명의 다양한 표기 방식 (예: "ENT", "이앤티")
- 빈 값과 0의 혼재
- 수기 입력 필드의 불완전한 데이터

이러한 분석 결과를 바탕으로 웹 시스템에서는 데이터 검증 규칙, 표준화된 입력 양식, 그리고 자동 완성 기능 등을 구현하여 데이터 품질을 향상시킬 필요가 있습니다.


## 데이터 모델링 및 관계 설계

### 정규화된 데이터베이스 스키마 설계

현재 엑셀의 평면적 구조를 관계형 데이터베이스로 전환하기 위해 다음과 같은 정규화된 스키마를 제안합니다.

**1. 핵심 엔티티 설계**

```sql
-- 대리점 마스터 테이블
CREATE TABLE agencies (
    agency_id INT PRIMARY KEY AUTO_INCREMENT,
    agency_code VARCHAR(20) UNIQUE NOT NULL,
    agency_name VARCHAR(100) NOT NULL,
    contact_person VARCHAR(50),
    phone VARCHAR(20),
    address TEXT,
    status ENUM('active', 'inactive') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 판매자 마스터 테이블
CREATE TABLE sellers (
    seller_id INT PRIMARY KEY AUTO_INCREMENT,
    seller_name VARCHAR(50) NOT NULL,
    agency_id INT,
    employee_id VARCHAR(20),
    hire_date DATE,
    status ENUM('active', 'inactive') DEFAULT 'active',
    FOREIGN KEY (agency_id) REFERENCES agencies(agency_id)
);

-- 통신사 마스터 테이블
CREATE TABLE carriers (
    carrier_id INT PRIMARY KEY AUTO_INCREMENT,
    carrier_code VARCHAR(10) UNIQUE NOT NULL,
    carrier_name VARCHAR(50) NOT NULL,
    commission_rate DECIMAL(5,2)
);

-- 개통 방식 마스터 테이블
CREATE TABLE activation_types (
    type_id INT PRIMARY KEY AUTO_INCREMENT,
    type_code VARCHAR(20) UNIQUE NOT NULL,
    type_name VARCHAR(50) NOT NULL,
    description TEXT
);

-- 기기 모델 마스터 테이블
CREATE TABLE device_models (
    model_id INT PRIMARY KEY AUTO_INCREMENT,
    model_code VARCHAR(50) UNIQUE NOT NULL,
    model_name VARCHAR(100) NOT NULL,
    manufacturer VARCHAR(50),
    category ENUM('smartphone', 'tablet', 'wired', 'other')
);
```

**2. 트랜잭션 테이블 설계**

```sql
-- 개통 트랜잭션 메인 테이블
CREATE TABLE activations (
    activation_id INT PRIMARY KEY AUTO_INCREMENT,
    seller_id INT NOT NULL,
    agency_id INT NOT NULL,
    carrier_id INT NOT NULL,
    activation_type_id INT NOT NULL,
    model_id INT,
    
    -- 고객 정보
    customer_name VARCHAR(100),
    customer_phone VARCHAR(20),
    customer_birth_date DATE,
    
    -- 기본 금액 정보
    face_value DECIMAL(10,2) DEFAULT 0,
    verbal_amount_1 DECIMAL(10,2) DEFAULT 0,
    verbal_amount_2 DECIMAL(10,2) DEFAULT 0,
    grade_amount DECIMAL(10,2) DEFAULT 0,
    additional_amount DECIMAL(10,2) DEFAULT 0,
    
    -- 계산된 금액
    total_rebate DECIMAL(10,2) GENERATED ALWAYS AS (
        face_value + verbal_amount_1 + verbal_amount_2 + grade_amount + additional_amount
    ) STORED,
    
    document_cash DECIMAL(10,2) DEFAULT 0,
    sim_fee DECIMAL(10,2) DEFAULT 0,
    new_number_discount DECIMAL(10,2) DEFAULT 0,
    deduction_amount DECIMAL(10,2) DEFAULT 0,
    
    -- 최종 정산금
    settlement_amount DECIMAL(10,2) GENERATED ALWAYS AS (
        total_rebate - document_cash + sim_fee + new_number_discount + deduction_amount
    ) STORED,
    
    -- 세금 및 마진
    tax_amount DECIMAL(10,2) GENERATED ALWAYS AS (
        settlement_amount * 0.133
    ) STORED,
    
    cash_received DECIMAL(10,2) DEFAULT 0,
    payback_amount DECIMAL(10,2) DEFAULT 0,
    
    pre_tax_margin DECIMAL(10,2) GENERATED ALWAYS AS (
        settlement_amount - tax_amount + cash_received + payback_amount
    ) STORED,
    
    post_tax_margin DECIMAL(10,2) GENERATED ALWAYS AS (
        tax_amount + pre_tax_margin
    ) STORED,
    
    -- 메타 정보
    activation_date DATE NOT NULL,
    serial_number VARCHAR(50),
    memo TEXT,
    status ENUM('pending', 'confirmed', 'cancelled') DEFAULT 'pending',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (seller_id) REFERENCES sellers(seller_id),
    FOREIGN KEY (agency_id) REFERENCES agencies(agency_id),
    FOREIGN KEY (carrier_id) REFERENCES carriers(carrier_id),
    FOREIGN KEY (activation_type_id) REFERENCES activation_types(type_id),
    FOREIGN KEY (model_id) REFERENCES device_models(model_id)
);
```

**3. 집계 및 정산 테이블**

```sql
-- 월별 정산 요약 테이블
CREATE TABLE monthly_settlements (
    settlement_id INT PRIMARY KEY AUTO_INCREMENT,
    year INT NOT NULL,
    month INT NOT NULL,
    
    -- 매출 관련
    total_settlement_amount DECIMAL(12,2) DEFAULT 0,
    total_revenue DECIMAL(12,2) DEFAULT 0,
    net_revenue DECIMAL(12,2) DEFAULT 0,
    
    -- 지출 관련
    total_expenses DECIMAL(12,2) DEFAULT 0,
    employee_salaries DECIMAL(12,2) DEFAULT 0,
    recovery_amounts DECIMAL(12,2) DEFAULT 0,
    
    -- 현금 흐름
    total_cash_received DECIMAL(12,2) DEFAULT 0,
    customer_paybacks DECIMAL(12,2) DEFAULT 0,
    bank_balance DECIMAL(12,2) DEFAULT 0,
    required_deposit DECIMAL(12,2) DEFAULT 0,
    
    -- 수익성
    net_profit DECIMAL(12,2) DEFAULT 0,
    actual_profit DECIMAL(12,2) DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY unique_month (year, month)
);

-- 대리점별 월간 성과 테이블
CREATE TABLE agency_monthly_performance (
    performance_id INT PRIMARY KEY AUTO_INCREMENT,
    agency_id INT NOT NULL,
    year INT NOT NULL,
    month INT NOT NULL,
    
    activation_count INT DEFAULT 0,
    total_settlement_amount DECIMAL(10,2) DEFAULT 0,
    agency_reported_amount DECIMAL(10,2) DEFAULT 0,
    difference_amount DECIMAL(10,2) GENERATED ALWAYS AS (
        agency_reported_amount - total_settlement_amount
    ) STORED,
    
    performance_rank INT,
    notes TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (agency_id) REFERENCES agencies(agency_id),
    UNIQUE KEY unique_agency_month (agency_id, year, month)
);
```

### 데이터 무결성 및 비즈니스 규칙

**1. 제약 조건 (Constraints)**

```sql
-- 금액 필드 검증
ALTER TABLE activations 
ADD CONSTRAINT chk_positive_amounts 
CHECK (face_value >= 0 AND settlement_amount >= 0);

-- 날짜 검증
ALTER TABLE activations 
ADD CONSTRAINT chk_valid_activation_date 
CHECK (activation_date >= '2020-01-01' AND activation_date <= CURDATE());

-- 전화번호 형식 검증
ALTER TABLE activations 
ADD CONSTRAINT chk_phone_format 
CHECK (customer_phone REGEXP '^[0-9]{10,11}$');
```

**2. 트리거를 통한 자동 집계**

```sql
-- 개통 데이터 입력/수정 시 월별 집계 자동 업데이트
DELIMITER //
CREATE TRIGGER update_monthly_settlement
AFTER INSERT ON activations
FOR EACH ROW
BEGIN
    INSERT INTO monthly_settlements (year, month, total_settlement_amount)
    VALUES (YEAR(NEW.activation_date), MONTH(NEW.activation_date), NEW.settlement_amount)
    ON DUPLICATE KEY UPDATE 
    total_settlement_amount = total_settlement_amount + NEW.settlement_amount;
END//
DELIMITER ;
```

**3. 뷰를 통한 복잡한 집계 쿼리 단순화**

```sql
-- 대리점별 실시간 성과 뷰
CREATE VIEW agency_performance_view AS
SELECT 
    a.agency_id,
    a.agency_name,
    COUNT(act.activation_id) as total_activations,
    SUM(act.settlement_amount) as total_settlement,
    AVG(act.settlement_amount) as avg_settlement,
    SUM(act.pre_tax_margin) as total_margin,
    RANK() OVER (ORDER BY SUM(act.settlement_amount) DESC) as performance_rank
FROM agencies a
LEFT JOIN activations act ON a.agency_id = act.agency_id
WHERE act.status = 'confirmed'
GROUP BY a.agency_id, a.agency_name;

-- 월별 트렌드 분석 뷰
CREATE VIEW monthly_trend_view AS
SELECT 
    YEAR(activation_date) as year,
    MONTH(activation_date) as month,
    COUNT(*) as activation_count,
    SUM(settlement_amount) as total_settlement,
    AVG(settlement_amount) as avg_settlement,
    SUM(pre_tax_margin) as total_margin,
    SUM(CASE WHEN carrier_id = 1 THEN 1 ELSE 0 END) as sk_count,
    SUM(CASE WHEN carrier_id = 2 THEN 1 ELSE 0 END) as kt_count,
    SUM(CASE WHEN carrier_id = 3 THEN 1 ELSE 0 END) as lg_count
FROM activations
WHERE status = 'confirmed'
GROUP BY YEAR(activation_date), MONTH(activation_date)
ORDER BY year DESC, month DESC;
```

### API 설계 및 데이터 접근 패턴

**1. RESTful API 엔드포인트 설계**

```javascript
// 개통 관리 API
GET    /api/activations              // 개통 목록 조회 (페이징, 필터링)
POST   /api/activations              // 새 개통 등록
GET    /api/activations/{id}         // 특정 개통 상세 조회
PUT    /api/activations/{id}         // 개통 정보 수정
DELETE /api/activations/{id}         // 개통 삭제

// 집계 및 분석 API
GET    /api/analytics/monthly        // 월별 집계 데이터
GET    /api/analytics/agencies       // 대리점별 성과 분석
GET    /api/analytics/trends         // 트렌드 분석 데이터
GET    /api/analytics/dashboard      // 대시보드 요약 데이터

// 마스터 데이터 API
GET    /api/agencies                 // 대리점 목록
GET    /api/sellers                  // 판매자 목록
GET    /api/carriers                 // 통신사 목록
GET    /api/device-models            // 기기 모델 목록
```

**2. 데이터 캐싱 전략**

```javascript
// Redis를 활용한 캐싱 구조
const cacheKeys = {
    monthlyStats: 'monthly_stats:{year}:{month}',
    agencyPerformance: 'agency_performance:{agency_id}',
    dashboardSummary: 'dashboard_summary:latest',
    masterData: 'master_data:{type}'
};

// 캐시 TTL 설정
const cacheTTL = {
    monthlyStats: 3600,      // 1시간
    agencyPerformance: 1800,  // 30분
    dashboardSummary: 300,    // 5분
    masterData: 86400         // 24시간
};
```

이러한 데이터 모델링 접근 방식을 통해 현재 엑셀의 복잡한 구조를 체계적이고 확장 가능한 데이터베이스 스키마로 전환할 수 있으며, 동시에 성능과 데이터 무결성을 보장할 수 있습니다.


## 웹 대시보드 ERP 아키텍처

### 시스템 아키텍처 개요

제안하는 웹 대시보드 ERP 시스템은 마이크로서비스 아키텍처를 기반으로 하여 확장성, 유지보수성, 그리고 성능을 최적화하도록 설계되었습니다. 전체 시스템은 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 계층, 그리고 인프라 계층으로 구성됩니다.

**아키텍처 구성 요소:**

1. **프론트엔드 (React + TypeScript)**
   - 반응형 웹 대시보드
   - 실시간 데이터 시각화
   - 사용자 인터페이스 컴포넌트

2. **백엔드 API (Node.js + Express)**
   - RESTful API 서버
   - 비즈니스 로직 처리
   - 인증 및 권한 관리

3. **데이터베이스 (MySQL + Redis)**
   - 관계형 데이터 저장
   - 캐싱 및 세션 관리
   - 실시간 데이터 처리

4. **인프라 (Docker + AWS/GCP)**
   - 컨테이너화된 배포
   - 클라우드 기반 확장성
   - 모니터링 및 로깅

### 프론트엔드 아키텍처 설계

**1. 컴포넌트 구조**

```typescript
// 메인 애플리케이션 구조
src/
├── components/           // 재사용 가능한 UI 컴포넌트
│   ├── common/          // 공통 컴포넌트
│   │   ├── Header.tsx
│   │   ├── Sidebar.tsx
│   │   ├── DataTable.tsx
│   │   └── Chart.tsx
│   ├── dashboard/       // 대시보드 컴포넌트
│   │   ├── SummaryCards.tsx
│   │   ├── RevenueChart.tsx
│   │   ├── AgencyRanking.tsx
│   │   └── RecentActivations.tsx
│   └── forms/           // 입력 폼 컴포넌트
│       ├── ActivationForm.tsx
│       ├── AgencyForm.tsx
│       └── SellerForm.tsx
├── pages/               // 페이지 컴포넌트
│   ├── Dashboard.tsx
│   ├── Activations.tsx
│   ├── Analytics.tsx
│   └── Settings.tsx
├── hooks/               // 커스텀 훅
│   ├── useApi.ts
│   ├── useAuth.ts
│   └── useWebSocket.ts
├── services/            // API 서비스
│   ├── activationService.ts
│   ├── analyticsService.ts
│   └── authService.ts
├── store/               // 상태 관리 (Redux Toolkit)
│   ├── slices/
│   │   ├── authSlice.ts
│   │   ├── activationSlice.ts
│   │   └── analyticsSlice.ts
│   └── store.ts
└── utils/               // 유틸리티 함수
    ├── formatters.ts
    ├── validators.ts
    └── constants.ts
```

**2. 상태 관리 전략**

```typescript
// Redux Toolkit을 활용한 상태 관리
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// 개통 데이터 상태 관리
export const fetchActivations = createAsyncThunk(
  'activations/fetchActivations',
  async (params: ActivationQueryParams) => {
    const response = await activationService.getActivations(params);
    return response.data;
  }
);

const activationSlice = createSlice({
  name: 'activations',
  initialState: {
    data: [],
    loading: false,
    error: null,
    pagination: {
      page: 1,
      limit: 20,
      total: 0
    },
    filters: {
      dateRange: null,
      agency: null,
      seller: null,
      status: 'all'
    }
  },
  reducers: {
    setFilters: (state, action) => {
      state.filters = { ...state.filters, ...action.payload };
    },
    clearFilters: (state) => {
      state.filters = initialState.filters;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchActivations.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchActivations.fulfilled, (state, action) => {
        state.loading = false;
        state.data = action.payload.items;
        state.pagination = action.payload.pagination;
      })
      .addCase(fetchActivations.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  }
});
```

**3. 실시간 데이터 업데이트**

```typescript
// WebSocket을 활용한 실시간 업데이트
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import io from 'socket.io-client';

export const useRealTimeUpdates = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    const socket = io(process.env.REACT_APP_WS_URL);

    socket.on('activation_created', (data) => {
      dispatch(addActivation(data));
      dispatch(updateDashboardStats());
    });

    socket.on('activation_updated', (data) => {
      dispatch(updateActivation(data));
    });

    socket.on('monthly_stats_updated', (data) => {
      dispatch(updateMonthlyStats(data));
    });

    return () => socket.disconnect();
  }, [dispatch]);
};
```

### 백엔드 아키텍처 설계

**1. 마이크로서비스 구조**

```javascript
// 서비스별 모듈 구조
backend/
├── services/
│   ├── auth-service/           // 인증 및 권한 관리
│   │   ├── controllers/
│   │   ├── middleware/
│   │   ├── models/
│   │   └── routes/
│   ├── activation-service/     // 개통 관리
│   │   ├── controllers/
│   │   ├── services/
│   │   ├── models/
│   │   └── routes/
│   ├── analytics-service/      // 분석 및 집계
│   │   ├── controllers/
│   │   ├── services/
│   │   └── routes/
│   └── notification-service/   // 알림 및 실시간 통신
│       ├── websocket/
│       ├── email/
│       └── sms/
├── shared/                     // 공통 모듈
│   ├── database/
│   ├── middleware/
│   ├── utils/
│   └── types/
└── gateway/                    // API 게이트웨이
    ├── routes/
    ├── middleware/
    └── proxy/
```

**2. 비즈니스 로직 계층**

```javascript
// 개통 서비스 비즈니스 로직
class ActivationService {
  constructor(activationRepository, analyticsService) {
    this.activationRepository = activationRepository;
    this.analyticsService = analyticsService;
  }

  async createActivation(activationData) {
    // 1. 데이터 검증
    const validatedData = await this.validateActivationData(activationData);
    
    // 2. 비즈니스 규칙 적용
    const processedData = await this.applyBusinessRules(validatedData);
    
    // 3. 마진 계산
    const calculatedData = this.calculateMargins(processedData);
    
    // 4. 데이터베이스 저장
    const savedActivation = await this.activationRepository.create(calculatedData);
    
    // 5. 집계 데이터 업데이트
    await this.analyticsService.updateMonthlyStats(savedActivation);
    
    // 6. 실시간 알림 발송
    await this.notificationService.broadcastActivationCreated(savedActivation);
    
    return savedActivation;
  }

  calculateMargins(activationData) {
    const {
      faceValue,
      verbalAmount1,
      verbalAmount2,
      gradeAmount,
      additionalAmount,
      documentCash,
      simFee,
      newNumberDiscount,
      deductionAmount,
      cashReceived,
      paybackAmount
    } = activationData;

    // 리베총계 계산
    const totalRebate = faceValue + verbalAmount1 + verbalAmount2 + 
                       gradeAmount + additionalAmount;

    // 정산금 계산
    const settlementAmount = totalRebate - documentCash + simFee + 
                           newNumberDiscount + deductionAmount;

    // 세금 계산 (13.3%)
    const taxAmount = settlementAmount * 0.133;

    // 세전 마진 계산
    const preTaxMargin = settlementAmount - taxAmount + cashReceived + paybackAmount;

    // 세후 마진 계산
    const postTaxMargin = taxAmount + preTaxMargin;

    return {
      ...activationData,
      totalRebate,
      settlementAmount,
      taxAmount,
      preTaxMargin,
      postTaxMargin
    };
  }
}
```

**3. 데이터 접근 계층**

```javascript
// Repository 패턴을 활용한 데이터 접근
class ActivationRepository {
  constructor(database) {
    this.db = database;
  }

  async findWithFilters(filters, pagination) {
    let query = this.db('activations as a')
      .leftJoin('agencies as ag', 'a.agency_id', 'ag.agency_id')
      .leftJoin('sellers as s', 'a.seller_id', 's.seller_id')
      .leftJoin('carriers as c', 'a.carrier_id', 'c.carrier_id')
      .select([
        'a.*',
        'ag.agency_name',
        's.seller_name',
        'c.carrier_name'
      ]);

    // 필터 적용
    if (filters.dateRange) {
      query = query.whereBetween('a.activation_date', 
        [filters.dateRange.start, filters.dateRange.end]);
    }

    if (filters.agency) {
      query = query.where('a.agency_id', filters.agency);
    }

    if (filters.seller) {
      query = query.where('a.seller_id', filters.seller);
    }

    if (filters.status && filters.status !== 'all') {
      query = query.where('a.status', filters.status);
    }

    // 페이징 적용
    const total = await query.clone().count('* as count').first();
    const items = await query
      .offset((pagination.page - 1) * pagination.limit)
      .limit(pagination.limit)
      .orderBy('a.created_at', 'desc');

    return {
      items,
      pagination: {
        ...pagination,
        total: total.count
      }
    };
  }

  async getMonthlyAggregation(year, month) {
    return await this.db('activations')
      .whereRaw('YEAR(activation_date) = ? AND MONTH(activation_date) = ?', [year, month])
      .select([
        this.db.raw('COUNT(*) as total_count'),
        this.db.raw('SUM(settlement_amount) as total_settlement'),
        this.db.raw('SUM(pre_tax_margin) as total_margin'),
        this.db.raw('AVG(settlement_amount) as avg_settlement'),
        this.db.raw('SUM(CASE WHEN carrier_id = 1 THEN 1 ELSE 0 END) as sk_count'),
        this.db.raw('SUM(CASE WHEN carrier_id = 2 THEN 1 ELSE 0 END) as kt_count'),
        this.db.raw('SUM(CASE WHEN carrier_id = 3 THEN 1 ELSE 0 END) as lg_count')
      ])
      .first();
  }
}
```

### 성능 최적화 전략

**1. 데이터베이스 최적화**

```sql
-- 인덱스 최적화
CREATE INDEX idx_activation_date ON activations(activation_date);
CREATE INDEX idx_agency_date ON activations(agency_id, activation_date);
CREATE INDEX idx_seller_date ON activations(seller_id, activation_date);
CREATE INDEX idx_status ON activations(status);

-- 복합 인덱스
CREATE INDEX idx_agency_seller_date ON activations(agency_id, seller_id, activation_date);

-- 파티셔닝 (월별)
ALTER TABLE activations 
PARTITION BY RANGE (YEAR(activation_date) * 100 + MONTH(activation_date)) (
    PARTITION p202501 VALUES LESS THAN (202502),
    PARTITION p202502 VALUES LESS THAN (202503),
    PARTITION p202503 VALUES LESS THAN (202504),
    -- ... 추가 파티션
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

**2. 캐싱 전략**

```javascript
// Redis를 활용한 다층 캐싱
class CacheService {
  constructor(redisClient) {
    this.redis = redisClient;
  }

  async getDashboardData(userId) {
    const cacheKey = `dashboard:${userId}`;
    
    // L1 캐시 확인
    let data = await this.redis.get(cacheKey);
    
    if (!data) {
      // 데이터베이스에서 조회
      data = await this.generateDashboardData(userId);
      
      // 캐시에 저장 (5분 TTL)
      await this.redis.setex(cacheKey, 300, JSON.stringify(data));
    } else {
      data = JSON.parse(data);
    }
    
    return data;
  }

  async invalidateCache(pattern) {
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

**3. API 응답 최적화**

```javascript
// 페이지네이션 및 필드 선택
app.get('/api/activations', async (req, res) => {
  const {
    page = 1,
    limit = 20,
    fields,
    ...filters
  } = req.query;

  // 필요한 필드만 선택
  const selectedFields = fields ? fields.split(',') : ['*'];
  
  const result = await activationService.findWithFilters(
    filters,
    { page: parseInt(page), limit: parseInt(limit) },
    selectedFields
  );

  // 응답 압축
  res.set('Content-Encoding', 'gzip');
  res.json(result);
});
```

이러한 아키텍처 설계를 통해 현재 엑셀 기반 시스템의 모든 기능을 웹 환경으로 성공적으로 이전할 수 있으며, 동시에 확장성과 성능을 크게 향상시킬 수 있습니다.


## 핵심 기능 및 화면 설계

### 대시보드 메인 화면

대시보드 메인 화면은 사용자가 시스템에 접속했을 때 가장 먼저 보게 되는 화면으로, 핵심 KPI와 실시간 현황을 한눈에 파악할 수 있도록 설계되어야 합니다.

**1. 상단 요약 카드 섹션**

```typescript
// 요약 카드 컴포넌트 구조
interface SummaryCardProps {
  title: string;
  value: number | string;
  change: number;
  changeType: 'increase' | 'decrease' | 'neutral';
  icon: ReactNode;
  format: 'currency' | 'number' | 'percentage';
}

const summaryCards = [
  {
    title: '이번 달 총 정산금',
    value: 440800,
    change: 12.5,
    changeType: 'increase',
    icon: <CurrencyIcon />,
    format: 'currency'
  },
  {
    title: '총 개통 건수',
    value: 44,
    change: -5.2,
    changeType: 'decrease',
    icon: <PhoneIcon />,
    format: 'number'
  },
  {
    title: '평균 마진',
    value: 16.8,
    change: 2.1,
    changeType: 'increase',
    icon: <TrendingUpIcon />,
    format: 'percentage'
  },
  {
    title: '순수익',
    value: -8169200,
    change: 0,
    changeType: 'neutral',
    icon: <ProfitIcon />,
    format: 'currency'
  }
];
```

**2. 실시간 차트 섹션**

```typescript
// 매출 트렌드 차트
const RevenueChart = () => {
  const [timeRange, setTimeRange] = useState('7days');
  const { data, loading } = useRevenueData(timeRange);

  const chartOptions = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: '매출 트렌드',
      },
    },
    scales: {
      y: {
        beginAtZero: true,
        ticks: {
          callback: (value) => formatCurrency(value),
        },
      },
    },
  };

  return (
    <Card>
      <CardHeader>
        <div className="flex justify-between items-center">
          <h3>매출 트렌드</h3>
          <Select value={timeRange} onValueChange={setTimeRange}>
            <SelectItem value="7days">최근 7일</SelectItem>
            <SelectItem value="30days">최근 30일</SelectItem>
            <SelectItem value="90days">최근 90일</SelectItem>
          </Select>
        </div>
      </CardHeader>
      <CardContent>
        {loading ? (
          <ChartSkeleton />
        ) : (
          <Line data={data} options={chartOptions} />
        )}
      </CardContent>
    </Card>
  );
};
```

**3. 대리점 성과 랭킹**

```typescript
// 대리점 랭킹 테이블
const AgencyRanking = () => {
  const { data: agencies } = useAgencyPerformance();

  return (
    <Card>
      <CardHeader>
        <h3>대리점 성과 랭킹</h3>
      </CardHeader>
      <CardContent>
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>순위</TableHead>
              <TableHead>대리점명</TableHead>
              <TableHead>개통수</TableHead>
              <TableHead>정산금</TableHead>
              <TableHead>마진</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {agencies.map((agency, index) => (
              <TableRow key={agency.id}>
                <TableCell>
                  <Badge variant={index < 3 ? 'default' : 'secondary'}>
                    {index + 1}
                  </Badge>
                </TableCell>
                <TableCell className="font-medium">
                  {agency.name}
                </TableCell>
                <TableCell>{agency.activationCount}</TableCell>
                <TableCell>{formatCurrency(agency.settlementAmount)}</TableCell>
                <TableCell>
                  <span className={agency.margin > 0 ? 'text-green-600' : 'text-red-600'}>
                    {formatCurrency(agency.margin)}
                  </span>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
};
```

### 개통 관리 화면

개통 관리 화면은 일일 업무의 핵심이 되는 화면으로, 개통 데이터의 입력, 수정, 조회 기능을 제공합니다.

**1. 개통 목록 화면**

```typescript
// 개통 목록 컴포넌트
const ActivationList = () => {
  const [filters, setFilters] = useState({
    dateRange: null,
    agency: '',
    seller: '',
    status: 'all'
  });
  
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 20
  });

  const { data, loading, refetch } = useActivations(filters, pagination);

  return (
    <div className="space-y-6">
      {/* 필터 섹션 */}
      <Card>
        <CardContent className="pt-6">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <DateRangePicker
              value={filters.dateRange}
              onChange={(range) => setFilters({...filters, dateRange: range})}
              placeholder="날짜 범위 선택"
            />
            <Select
              value={filters.agency}
              onValueChange={(value) => setFilters({...filters, agency: value})}
            >
              <SelectTrigger>
                <SelectValue placeholder="대리점 선택" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">전체</SelectItem>
                {agencies.map(agency => (
                  <SelectItem key={agency.id} value={agency.id}>
                    {agency.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Select
              value={filters.seller}
              onValueChange={(value) => setFilters({...filters, seller: value})}
            >
              <SelectTrigger>
                <SelectValue placeholder="판매자 선택" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">전체</SelectItem>
                {sellers.map(seller => (
                  <SelectItem key={seller.id} value={seller.id}>
                    {seller.name}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button onClick={() => refetch()}>
              <SearchIcon className="w-4 h-4 mr-2" />
              검색
            </Button>
          </div>
        </CardContent>
      </Card>

      {/* 액션 버튼 */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">개통 목록</h2>
        <div className="space-x-2">
          <Button variant="outline">
            <DownloadIcon className="w-4 h-4 mr-2" />
            엑셀 다운로드
          </Button>
          <Button onClick={() => setShowCreateModal(true)}>
            <PlusIcon className="w-4 h-4 mr-2" />
            새 개통 등록
          </Button>
        </div>
      </div>

      {/* 데이터 테이블 */}
      <Card>
        <CardContent>
          <DataTable
            columns={activationColumns}
            data={data?.items || []}
            loading={loading}
            pagination={data?.pagination}
            onPaginationChange={setPagination}
            onRowClick={(row) => setSelectedActivation(row)}
          />
        </CardContent>
      </Card>
    </div>
  );
};
```

**2. 개통 등록/수정 폼**

```typescript
// 개통 폼 컴포넌트
const ActivationForm = ({ activation, onSubmit, onCancel }) => {
  const form = useForm({
    resolver: zodResolver(activationSchema),
    defaultValues: activation || {
      sellerName: '',
      agencyId: '',
      carrierId: '',
      activationType: '',
      modelName: '',
      customerName: '',
      customerPhone: '',
      customerBirthDate: '',
      faceValue: 0,
      verbalAmount1: 0,
      verbalAmount2: 0,
      gradeAmount: 0,
      additionalAmount: 0,
      documentCash: 0,
      simFee: 0,
      newNumberDiscount: 0,
      deductionAmount: 0,
      cashReceived: 0,
      paybackAmount: 0,
      memo: ''
    }
  });

  // 실시간 마진 계산
  const watchedValues = form.watch();
  const calculatedMargins = useMemo(() => {
    return calculateMargins(watchedValues);
  }, [watchedValues]);

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* 기본 정보 섹션 */}
        <Card>
          <CardHeader>
            <CardTitle>기본 정보</CardTitle>
          </CardHeader>
          <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField
              control={form.control}
              name="sellerName"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>판매자</FormLabel>
                  <FormControl>
                    <Input {...field} placeholder="판매자명 입력" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="agencyId"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>대리점</FormLabel>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="대리점 선택" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {agencies.map(agency => (
                        <SelectItem key={agency.id} value={agency.id}>
                          {agency.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            {/* 추가 필드들... */}
          </CardContent>
        </Card>

        {/* 고객 정보 섹션 */}
        <Card>
          <CardHeader>
            <CardTitle>고객 정보</CardTitle>
          </CardHeader>
          <CardContent className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <FormField
              control={form.control}
              name="customerName"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>고객명</FormLabel>
                  <FormControl>
                    <Input {...field} placeholder="고객명 입력" />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="customerPhone"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>휴대폰번호</FormLabel>
                  <FormControl>
                    <Input 
                      {...field} 
                      placeholder="010-0000-0000"
                      onChange={(e) => {
                        const formatted = formatPhoneNumber(e.target.value);
                        field.onChange(formatted);
                      }}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="customerBirthDate"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>생년월일</FormLabel>
                  <FormControl>
                    <Input 
                      {...field} 
                      type="date"
                      max={new Date().toISOString().split('T')[0]}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
          </CardContent>
        </Card>

        {/* 금액 정보 섹션 */}
        <Card>
          <CardHeader>
            <CardTitle>금액 정보</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <FormField
                control={form.control}
                name="faceValue"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>액면/셋팅가</FormLabel>
                    <FormControl>
                      <Input 
                        {...field} 
                        type="number"
                        placeholder="0"
                        onChange={(e) => field.onChange(Number(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              {/* 추가 금액 필드들... */}
            </div>

            {/* 실시간 계산 결과 표시 */}
            <div className="bg-gray-50 p-4 rounded-lg">
              <h4 className="font-semibold mb-3">계산 결과</h4>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div>
                  <span className="text-gray-600">리베총계:</span>
                  <span className="font-medium ml-2">
                    {formatCurrency(calculatedMargins.totalRebate)}
                  </span>
                </div>
                <div>
                  <span className="text-gray-600">정산금:</span>
                  <span className="font-medium ml-2">
                    {formatCurrency(calculatedMargins.settlementAmount)}
                  </span>
                </div>
                <div>
                  <span className="text-gray-600">세전마진:</span>
                  <span className="font-medium ml-2">
                    {formatCurrency(calculatedMargins.preTaxMargin)}
                  </span>
                </div>
                <div>
                  <span className="text-gray-600">세후마진:</span>
                  <span className="font-medium ml-2 text-green-600">
                    {formatCurrency(calculatedMargins.postTaxMargin)}
                  </span>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* 액션 버튼 */}
        <div className="flex justify-end space-x-2">
          <Button type="button" variant="outline" onClick={onCancel}>
            취소
          </Button>
          <Button type="submit">
            {activation ? '수정' : '등록'}
          </Button>
        </div>
      </form>
    </Form>
  );
};
```

### 분석 및 리포트 화면

분석 화면은 경영진과 관리자가 비즈니스 인사이트를 얻을 수 있도록 다양한 차트와 리포트를 제공합니다.

**1. 매출 분석 대시보드**

```typescript
// 매출 분석 컴포넌트
const RevenueAnalytics = () => {
  const [period, setPeriod] = useState('monthly');
  const [comparison, setComparison] = useState('previous');
  
  const { data: revenueData } = useRevenueAnalytics(period, comparison);
  const { data: agencyComparison } = useAgencyComparison(period);

  return (
    <div className="space-y-6">
      {/* 분석 옵션 */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex space-x-4">
            <Select value={period} onValueChange={setPeriod}>
              <SelectTrigger className="w-40">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="daily">일별</SelectItem>
                <SelectItem value="weekly">주별</SelectItem>
                <SelectItem value="monthly">월별</SelectItem>
                <SelectItem value="quarterly">분기별</SelectItem>
              </SelectContent>
            </Select>
            <Select value={comparison} onValueChange={setComparison}>
              <SelectTrigger className="w-40">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="previous">이전 기간</SelectItem>
                <SelectItem value="year">작년 동기</SelectItem>
                <SelectItem value="target">목표 대비</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* 매출 트렌드 차트 */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>매출 트렌드</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <LineChart data={revenueData.trend}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="period" />
                <YAxis tickFormatter={formatCurrency} />
                <Tooltip formatter={(value) => formatCurrency(value)} />
                <Legend />
                <Line 
                  type="monotone" 
                  dataKey="current" 
                  stroke="#8884d8" 
                  name="현재 기간"
                />
                <Line 
                  type="monotone" 
                  dataKey="previous" 
                  stroke="#82ca9d" 
                  name="이전 기간"
                />
              </LineChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>대리점별 매출 비교</CardTitle>
          </CardHeader>
          <CardContent>
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={agencyComparison}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="agencyName" />
                <YAxis tickFormatter={formatCurrency} />
                <Tooltip formatter={(value) => formatCurrency(value)} />
                <Bar dataKey="revenue" fill="#8884d8" />
              </BarChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      </div>

      {/* 상세 분석 테이블 */}
      <Card>
        <CardHeader>
          <CardTitle>상세 분석</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>구분</TableHead>
                <TableHead>현재 기간</TableHead>
                <TableHead>이전 기간</TableHead>
                <TableHead>증감률</TableHead>
                <TableHead>목표 달성률</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {revenueData.details.map((item) => (
                <TableRow key={item.category}>
                  <TableCell className="font-medium">{item.category}</TableCell>
                  <TableCell>{formatCurrency(item.current)}</TableCell>
                  <TableCell>{formatCurrency(item.previous)}</TableCell>
                  <TableCell>
                    <span className={item.changeRate > 0 ? 'text-green-600' : 'text-red-600'}>
                      {item.changeRate > 0 ? '+' : ''}{item.changeRate.toFixed(1)}%
                    </span>
                  </TableCell>
                  <TableCell>
                    <Progress value={item.achievementRate} className="w-20" />
                    <span className="ml-2 text-sm">{item.achievementRate.toFixed(1)}%</span>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
};
```

이러한 화면 설계를 통해 사용자들은 직관적이고 효율적으로 업무를 처리할 수 있으며, 실시간 데이터 업데이트와 상호작용을 통해 더 나은 의사결정을 내릴 수 있습니다.


## 기술 스택 및 구현 방안

### 프론트엔드 기술 스택

**1. 핵심 프레임워크 및 라이브러리**

```json
{
  "dependencies": {
    "react": "^18.2.0",
    "typescript": "^5.0.0",
    "next.js": "^14.0.0",
    "tailwindcss": "^3.3.0",
    "@radix-ui/react-*": "^1.0.0",
    "react-hook-form": "^7.45.0",
    "zod": "^3.22.0",
    "@tanstack/react-query": "^4.32.0",
    "recharts": "^2.8.0",
    "react-table": "^8.10.0",
    "socket.io-client": "^4.7.0",
    "date-fns": "^2.30.0",
    "react-hot-toast": "^2.4.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "@types/node": "^20.5.0",
    "eslint": "^8.47.0",
    "prettier": "^3.0.0",
    "jest": "^29.6.0",
    "@testing-library/react": "^13.4.0"
  }
}
```

**2. UI 컴포넌트 시스템**

```typescript
// 디자인 시스템 토큰
export const designTokens = {
  colors: {
    primary: {
      50: '#eff6ff',
      100: '#dbeafe',
      500: '#3b82f6',
      600: '#2563eb',
      900: '#1e3a8a'
    },
    success: {
      50: '#f0fdf4',
      500: '#22c55e',
      600: '#16a34a'
    },
    warning: {
      50: '#fffbeb',
      500: '#f59e0b',
      600: '#d97706'
    },
    error: {
      50: '#fef2f2',
      500: '#ef4444',
      600: '#dc2626'
    }
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '2rem',
    '2xl': '3rem'
  },
  typography: {
    fontFamily: {
      sans: ['Inter', 'system-ui', 'sans-serif'],
      mono: ['JetBrains Mono', 'monospace']
    },
    fontSize: {
      xs: '0.75rem',
      sm: '0.875rem',
      base: '1rem',
      lg: '1.125rem',
      xl: '1.25rem',
      '2xl': '1.5rem',
      '3xl': '1.875rem'
    }
  }
};
```

### 백엔드 기술 스택

**1. 서버 및 데이터베이스**

```json
{
  "dependencies": {
    "express": "^4.18.0",
    "typescript": "^5.0.0",
    "mysql2": "^3.6.0",
    "knex": "^2.5.0",
    "redis": "^4.6.0",
    "socket.io": "^4.7.0",
    "jsonwebtoken": "^9.0.0",
    "bcryptjs": "^2.4.0",
    "joi": "^17.9.0",
    "winston": "^3.10.0",
    "helmet": "^7.0.0",
    "cors": "^2.8.0",
    "compression": "^1.7.0",
    "rate-limiter-flexible": "^3.0.0"
  },
  "devDependencies": {
    "@types/express": "^4.17.0",
    "@types/node": "^20.5.0",
    "nodemon": "^3.0.0",
    "jest": "^29.6.0",
    "supertest": "^6.3.0"
  }
}
```

**2. 환경 설정 및 보안**

```typescript
// 환경 변수 설정
export const config = {
  server: {
    port: process.env.PORT || 3000,
    env: process.env.NODE_ENV || 'development'
  },
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306'),
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'erp_system',
    connectionLimit: 10,
    acquireTimeout: 60000,
    timeout: 60000
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD || ''
  },
  jwt: {
    secret: process.env.JWT_SECRET || 'your-secret-key',
    expiresIn: '24h'
  },
  security: {
    bcryptRounds: 12,
    rateLimitWindow: 15 * 60 * 1000, // 15분
    rateLimitMax: 100 // 요청 제한
  }
};
```

### 배포 및 인프라

**1. Docker 컨테이너화**

```dockerfile
# 프론트엔드 Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

```dockerfile
# 백엔드 Dockerfile
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE 3000
CMD ["npm", "start"]
```

**2. Docker Compose 설정**

```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    environment:
      - REACT_APP_API_URL=http://backend:3000

  backend:
    build: ./backend
    ports:
      - "3000:3000"
    depends_on:
      - mysql
      - redis
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - REDIS_HOST=redis
    volumes:
      - ./logs:/app/logs

  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword
      - MYSQL_DATABASE=erp_system
    volumes:
      - mysql_data:/var/lib/mysql
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  mysql_data:
  redis_data:
```

## 단계별 구현 로드맵

### Phase 1: 기반 구조 구축 (4-6주)

**1주차: 프로젝트 설정 및 환경 구성**
- 개발 환경 설정 (Node.js, React, TypeScript)
- 프로젝트 구조 생성 및 초기 설정
- Git 저장소 설정 및 CI/CD 파이프라인 구성
- 데이터베이스 스키마 설계 및 생성

**2주차: 인증 및 권한 시스템**
- JWT 기반 인증 시스템 구현
- 사용자 관리 기능 (로그인, 로그아웃, 권한 관리)
- 보안 미들웨어 구현
- 기본 UI 컴포넌트 라이브러리 구축

**3-4주차: 핵심 데이터 모델 구현**
- 개통 데이터 CRUD API 개발
- 대리점, 판매자, 통신사 마스터 데이터 관리
- 기본적인 비즈니스 로직 구현 (마진 계산 등)
- 데이터 검증 및 에러 처리

**5-6주차: 기본 UI 구현**
- 대시보드 레이아웃 구성
- 개통 목록 및 등록 화면 구현
- 기본적인 필터링 및 검색 기능
- 반응형 디자인 적용

### Phase 2: 핵심 기능 개발 (6-8주)

**7-8주차: 개통 관리 고도화**
- 복잡한 개통 등록 폼 구현
- 실시간 마진 계산 기능
- 대량 데이터 입력 기능 (엑셀 업로드)
- 데이터 검증 및 중복 체크

**9-10주차: 집계 및 분석 기능**
- 월별 정산 자동 계산 시스템
- 대리점별 성과 분석 기능
- 실시간 대시보드 구현
- 기본적인 차트 및 그래프

**11-12주차: 고급 분석 기능**
- 트렌드 분석 및 예측 기능
- 비교 분석 (기간별, 대리점별)
- 커스텀 리포트 생성 기능
- 데이터 내보내기 (PDF, Excel)

**13-14주차: 성능 최적화**
- 데이터베이스 쿼리 최적화
- 캐싱 시스템 구현
- 페이지네이션 및 가상 스크롤링
- API 응답 시간 개선

### Phase 3: 고급 기능 및 최적화 (4-6주)

**15-16주차: 실시간 기능**
- WebSocket 기반 실시간 업데이트
- 알림 시스템 구현
- 실시간 협업 기능
- 동시 편집 충돌 방지

**17-18주차: 모바일 최적화**
- 모바일 반응형 디자인 개선
- PWA (Progressive Web App) 구현
- 오프라인 기능 지원
- 모바일 전용 UI 컴포넌트

**19-20주차: 배포 및 운영**
- 프로덕션 환경 배포
- 모니터링 및 로깅 시스템
- 백업 및 복구 시스템
- 성능 모니터링 및 알림

### Phase 4: 확장 및 고도화 (지속적)

**추가 기능 개발**
- AI 기반 예측 분석
- 자동화된 정산 시스템
- 외부 시스템 연동 (통신사 API 등)
- 고급 보고서 및 대시보드

**운영 및 유지보수**
- 사용자 피드백 수집 및 개선
- 정기적인 보안 업데이트
- 성능 모니터링 및 최적화
- 새로운 기능 요구사항 분석 및 개발

## 결론 및 권장사항

### 주요 성과 예상 효과

본 웹 대시보드 ERP 시스템 구축을 통해 다음과 같은 주요 성과를 기대할 수 있습니다:

**1. 업무 효율성 향상**
- 엑셀 기반 수작업을 자동화하여 업무 처리 시간 70% 단축
- 실시간 데이터 업데이트로 정보 지연 시간 최소화
- 표준화된 입력 양식으로 데이터 입력 오류 90% 감소
- 자동 계산 기능으로 계산 실수 완전 제거

**2. 데이터 정확성 및 일관성 확보**
- 데이터베이스 제약 조건을 통한 데이터 무결성 보장
- 실시간 검증 시스템으로 잘못된 데이터 입력 방지
- 표준화된 마스터 데이터로 일관성 있는 정보 관리
- 감사 추적 기능으로 모든 변경 사항 추적 가능

**3. 의사결정 지원 강화**
- 실시간 대시보드를 통한 즉각적인 현황 파악
- 다양한 분석 도구로 심층적인 비즈니스 인사이트 제공
- 트렌드 분석을 통한 미래 예측 및 계획 수립 지원
- 대리점별 성과 비교를 통한 효과적인 관리 방안 도출

**4. 확장성 및 유지보수성**
- 마이크로서비스 아키텍처로 기능별 독립적 확장 가능
- 클라우드 기반 인프라로 사용량에 따른 탄력적 확장
- 모듈화된 구조로 새로운 기능 추가 용이
- 체계적인 코드 관리로 유지보수 비용 절감

### 핵심 권장사항

**1. 단계적 구현 접근**
전체 시스템을 한 번에 구축하기보다는 제안된 4단계 로드맵에 따라 점진적으로 구현하는 것을 강력히 권장합니다. 이를 통해 사용자 피드백을 조기에 수집하고 반영할 수 있으며, 리스크를 최소화할 수 있습니다.

**2. 사용자 중심 설계**
현재 엑셀을 사용하는 직원들의 업무 패턴과 요구사항을 충분히 분석하여 사용자 친화적인 인터페이스를 설계해야 합니다. 특히 기존 엑셀 사용자들이 쉽게 적응할 수 있도록 유사한 UI/UX 패턴을 적용하는 것이 중요합니다.

**3. 데이터 마이그레이션 전략**
기존 엑셀 데이터를 새로운 시스템으로 이전하는 과정에서 데이터 손실이나 오류가 발생하지 않도록 체계적인 마이그레이션 계획을 수립해야 합니다. 이를 위해 데이터 검증 도구와 백업 시스템을 구축하는 것이 필수적입니다.

**4. 교육 및 지원 체계**
새로운 시스템 도입 시 사용자 교육과 지속적인 기술 지원이 성공의 핵심 요소입니다. 단계별 교육 프로그램과 사용자 매뉴얼, 그리고 실시간 지원 체계를 구축하여 원활한 시스템 전환을 지원해야 합니다.

**5. 보안 및 백업**
민감한 비즈니스 데이터를 다루는 시스템인 만큼 강력한 보안 체계와 정기적인 백업 시스템을 구축해야 합니다. 특히 개인정보 보호법과 관련 규정을 준수하는 것이 중요합니다.

### 기대 투자 수익률 (ROI)

**비용 절감 효과:**
- 업무 시간 단축으로 인한 인건비 절약: 연간 약 30% 절감
- 데이터 오류 감소로 인한 손실 방지: 연간 약 20% 절감
- 종이 및 인쇄 비용 절약: 연간 약 80% 절감
- 시스템 유지보수 비용 최적화: 연간 약 40% 절감

**매출 증대 효과:**
- 실시간 분석을 통한 의사결정 개선으로 매출 5-10% 증대
- 대리점 성과 관리 개선으로 전체 수익성 향상
- 고객 서비스 품질 향상으로 고객 만족도 및 재구매율 증가

**예상 투자 회수 기간:** 12-18개월

본 웹 대시보드 ERP 시스템은 단순한 엑셀 대체가 아닌, 비즈니스 프로세스 전반의 디지털 혁신을 통해 경쟁력을 강화하고 지속 가능한 성장 기반을 마련하는 전략적 투자입니다. 제안된 설계 방안과 구현 로드맵을 따라 체계적으로 진행한다면, 현재의 업무 효율성 문제를 해결하고 미래 성장을 위한 견고한 기반을 구축할 수 있을 것입니다.

