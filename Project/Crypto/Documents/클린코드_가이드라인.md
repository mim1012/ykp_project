# í´ë¦° ì½”ë“œ ê°€ì´ë“œë¼ì¸
## Clean Code Guidelines for Crypto Auto-Trading System

---

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

| í•­ëª© | ë‚´ìš© |
|------|------|
| **ë¬¸ì„œëª…** | í´ë¦° ì½”ë“œ ê°€ì´ë“œë¼ì¸ |
| **ë²„ì „** | v1.0 |
| **ì‘ì„±ì¼** | 2025ë…„ 8ì›” 31ì¼ |
| **ëŒ€ìƒ** | ëª¨ë“  ê°œë°œ ì—ì´ì „íŠ¸ |
| **ëª©ì ** | ì¼ê´€ëœ ì½”ë“œ í’ˆì§ˆ ë° ìœ ì§€ë³´ìˆ˜ì„± í™•ë³´ |

---

## ğŸ¯ 1. í´ë¦° ì½”ë“œ ì² í•™

### 1.1 í•µì‹¬ ì›ì¹™
**"ì½”ë“œëŠ” ì‚¬ëŒì´ ì½ê¸° ìœ„í•´ ì‘ì„±ë˜ë©°, ê¸°ê³„ê°€ ì‹¤í–‰í•˜ëŠ” ê²ƒì€ ë¶€ì°¨ì ì´ë‹¤"**

```python
# âŒ ë‚˜ìœ ì˜ˆ
def calc(d, r, t):
    return d * (1 + r) ** t

# âœ… ì¢‹ì€ ì˜ˆ
def calculate_compound_interest(principal: float, rate: float, time: int) -> float:
    """
    ë³µë¦¬ ì´ìë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
    
    Args:
        principal: ì›ê¸ˆ
        rate: ì—°ì´ìœ¨ (ì†Œìˆ˜ì  í˜•íƒœ, ì˜ˆ: 0.05 = 5%)
        time: íˆ¬ì ê¸°ê°„ (ë…„)
    
    Returns:
        ë³µë¦¬ ì´ìê°€ ì ìš©ëœ ìµœì¢… ê¸ˆì•¡
    """
    return principal * (1 + rate) ** time
```

### 1.2 í’ˆì§ˆ ì§€í‘œ
- **ê°€ë…ì„±**: ì½”ë“œë¥¼ ì²˜ìŒ ë³´ëŠ” ì‚¬ëŒë„ 5ë¶„ ë‚´ì— ì´í•´ ê°€ëŠ¥
- **ìœ ì§€ë³´ìˆ˜ì„±**: ê¸°ëŠ¥ ë³€ê²½ ì‹œ ìµœì†Œí•œì˜ ì½”ë“œ ìˆ˜ì •
- **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±**: ëª¨ë“  í•¨ìˆ˜ê°€ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- **ì„±ëŠ¥**: ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ìµœì ì˜ ì„±ëŠ¥

---

## ğŸ—ï¸ 2. ì•„í‚¤í…ì²˜ ì„¤ê³„ ì›ì¹™

### 2.1 SOLID ì›ì¹™

**Single Responsibility Principle (ë‹¨ì¼ ì±…ì„ ì›ì¹™)**
```python
# âŒ ë‚˜ìœ ì˜ˆ: ì—¬ëŸ¬ ì±…ì„ì„ ê°€ì§„ í´ë˜ìŠ¤
class TradingManager:
    def get_market_data(self):
        pass
    
    def calculate_signals(self):
        pass
    
    def execute_orders(self):
        pass
    
    def send_notifications(self):
        pass

# âœ… ì¢‹ì€ ì˜ˆ: ë‹¨ì¼ ì±…ì„ìœ¼ë¡œ ë¶„ë¦¬
class MarketDataProvider:
    """ì‹œì¥ ë°ì´í„° ì œê³µ ì „ìš©"""
    def get_market_data(self) -> MarketData:
        pass

class SignalCalculator:
    """ì‹ í˜¸ ê³„ì‚° ì „ìš©"""
    def calculate_signals(self, data: MarketData) -> List[Signal]:
        pass

class OrderExecutor:
    """ì£¼ë¬¸ ì‹¤í–‰ ì „ìš©"""
    def execute_orders(self, signals: List[Signal]) -> List[Order]:
        pass

class NotificationService:
    """ì•Œë¦¼ ì „ì†¡ ì „ìš©"""
    def send_notifications(self, orders: List[Order]) -> None:
        pass
```

**Open/Closed Principle (ê°œë°©/íì‡„ ì›ì¹™)**
```python
from abc import ABC, abstractmethod

# âœ… í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³ , ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆëŠ” ì„¤ê³„
class EntryCondition(ABC):
    """ì§„ì… ì¡°ê±´ ì¶”ìƒ í´ë˜ìŠ¤"""
    
    @abstractmethod
    def evaluate(self, market_data: MarketData) -> Signal:
        pass
    
    @abstractmethod
    def is_active(self) -> bool:
        pass

class MovingAverageCondition(EntryCondition):
    """ì´ë™í‰ê·  ì¡°ê±´ - ìƒˆë¡œìš´ ì¡°ê±´ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”"""
    
    def __init__(self, period: int, condition_type: str):
        self.period = period
        self.condition_type = condition_type
        self._active = True
    
    def evaluate(self, market_data: MarketData) -> Signal:
        ma_value = self._calculate_moving_average(market_data)
        current_price = market_data.close
        
        if self.condition_type == "close_above" and current_price > ma_value:
            return Signal("BUY", current_price, confidence=0.8)
        elif self.condition_type == "close_below" and current_price < ma_value:
            return Signal("SELL", current_price, confidence=0.8)
        
        return None
    
    def is_active(self) -> bool:
        return self._active

class PriceChannelCondition(EntryCondition):
    """Price Channel ì¡°ê±´ - ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ì´ ìƒˆ ì¡°ê±´ ì¶”ê°€"""
    
    def evaluate(self, market_data: MarketData) -> Signal:
        # Price Channel ë¡œì§ êµ¬í˜„
        pass
    
    def is_active(self) -> bool:
        return self._active
```

**Liskov Substitution Principle (ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™)**
```python
# âœ… ë¶€ëª¨ í´ë˜ìŠ¤ë¥¼ ìì‹ í´ë˜ìŠ¤ë¡œ ì¹˜í™˜ ê°€ëŠ¥í•œ ì„¤ê³„
class APIConnector(ABC):
    @abstractmethod
    async def get_account_info(self) -> AccountInfo:
        pass
    
    @abstractmethod
    async def place_order(self, order: Order) -> OrderResult:
        pass

class BinanceConnector(APIConnector):
    async def get_account_info(self) -> AccountInfo:
        # ë°”ì´ë‚¸ìŠ¤ API í˜¸ì¶œ
        response = await self._api_call("/fapi/v2/account")
        return AccountInfo.from_binance_response(response)
    
    async def place_order(self, order: Order) -> OrderResult:
        # ë°”ì´ë‚¸ìŠ¤ ì£¼ë¬¸ ì‹¤í–‰
        response = await self._api_call("/fapi/v1/order", order.to_binance_params())
        return OrderResult.from_binance_response(response)

class BybitConnector(APIConnector):
    async def get_account_info(self) -> AccountInfo:
        # ë°”ì´ë¹„íŠ¸ API í˜¸ì¶œ - ê°™ì€ ì¸í„°í˜ì´ìŠ¤, ë‹¤ë¥¸ êµ¬í˜„
        response = await self._api_call("/v2/private/wallet/balance")
        return AccountInfo.from_bybit_response(response)
    
    async def place_order(self, order: Order) -> OrderResult:
        # ë°”ì´ë¹„íŠ¸ ì£¼ë¬¸ ì‹¤í–‰
        response = await self._api_call("/private/linear/order/create", order.to_bybit_params())
        return OrderResult.from_bybit_response(response)

# ì‚¬ìš© ì‹œ - ì–´ë–¤ êµ¬í˜„ì²´ë“  ë™ì¼í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥
async def execute_trading_logic(connector: APIConnector):
    account = await connector.get_account_info()  # ì–´ë–¤ ê±°ë˜ì†Œë“  ë™ì¼í•œ ë°©ì‹
    if account.has_sufficient_balance():
        order = Order("BUY", "BTCUSDT", 0.1)
        result = await connector.place_order(order)
```

### 2.2 ì˜ì¡´ì„± ì£¼ì… (Dependency Injection)

```python
# âœ… ì˜ì¡´ì„± ì£¼ì…ì„ í†µí•œ ìœ ì—°í•œ ì„¤ê³„
class TradingEngine:
    def __init__(self, 
                 data_provider: MarketDataProvider,
                 signal_calculator: SignalCalculator,
                 order_executor: OrderExecutor,
                 risk_manager: RiskManager,
                 logger: Logger):
        self.data_provider = data_provider
        self.signal_calculator = signal_calculator
        self.order_executor = order_executor
        self.risk_manager = risk_manager
        self.logger = logger
    
    async def run_trading_cycle(self):
        """ê±°ë˜ ì‚¬ì´í´ ì‹¤í–‰"""
        try:
            # 1. ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘
            market_data = await self.data_provider.get_latest_data()
            
            # 2. ì‹ í˜¸ ê³„ì‚°
            signals = self.signal_calculator.calculate_signals(market_data)
            
            # 3. ë¦¬ìŠ¤í¬ ê²€ì¦
            validated_signals = self.risk_manager.validate_signals(signals)
            
            # 4. ì£¼ë¬¸ ì‹¤í–‰
            if validated_signals:
                orders = await self.order_executor.execute_orders(validated_signals)
                self.logger.info(f"Executed {len(orders)} orders")
        
        except Exception as e:
            self.logger.error(f"Trading cycle failed: {e}")
            raise

# ì˜ì¡´ì„± ì¡°ë¦½ (Dependency Assembly)
def create_trading_engine() -> TradingEngine:
    """ê±°ë˜ ì—”ì§„ ìƒì„± - ì˜ì¡´ì„± ì£¼ì…"""
    config = load_config()
    
    # ì˜ì¡´ì„± ìƒì„±
    data_provider = BinanceDataProvider(config.api_key, config.secret)
    signal_calculator = SignalCalculator(config.entry_conditions)
    order_executor = OrderExecutor(data_provider.api_connector)
    risk_manager = RiskManager(config.risk_settings)
    logger = create_logger("trading_engine")
    
    # ì—”ì§„ ìƒì„± ë° ë°˜í™˜
    return TradingEngine(
        data_provider=data_provider,
        signal_calculator=signal_calculator,
        order_executor=order_executor,
        risk_manager=risk_manager,
        logger=logger
    )
```

---

## ğŸ“ 3. ë„¤ì´ë° ì»¨ë²¤ì…˜

### 3.1 ë³€ìˆ˜ ë° í•¨ìˆ˜ëª…

**ëª…í™•í•˜ê³  ì˜ë¯¸ ìˆëŠ” ì´ë¦„ ì‚¬ìš©**
```python
# âŒ ë‚˜ìœ ì˜ˆ
d = 50000.0  # ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€ ë¶ˆë¶„ëª…
calc_pnl(p, e)  # ì•½ì–´ ì‚¬ìš©ìœ¼ë¡œ ì˜ë¯¸ íŒŒì•… ì–´ë ¤ì›€

# âœ… ì¢‹ì€ ì˜ˆ
current_btc_price = 50000.0
calculate_profit_and_loss(position: Position, exit_price: float)
```

**ë™ì‚¬ + ëª…ì‚¬ íŒ¨í„´ (í•¨ìˆ˜)**
```python
# âœ… í•¨ìˆ˜ëª…ì€ ë™ì‘ì„ ëª…í™•íˆ í‘œí˜„
def validate_order_parameters(order: Order) -> bool:
    """ì£¼ë¬¸ íŒŒë¼ë¯¸í„° ê²€ì¦"""
    pass

def calculate_position_size(account_balance: float, risk_percentage: float) -> float:
    """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
    pass

def execute_market_order(symbol: str, side: str, quantity: float) -> OrderResult:
    """ì‹œì¥ê°€ ì£¼ë¬¸ ì‹¤í–‰"""
    pass
```

**ë¶ˆë¦° ë³€ìˆ˜ ë° í•¨ìˆ˜**
```python
# âœ… is_, has_, can_, should_ ì ‘ë‘ì‚¬ ì‚¬ìš©
is_position_open = True
has_sufficient_balance = account.balance > required_amount
can_place_order = risk_manager.validate_order(order)

def is_market_open() -> bool:
    """ì‹œì¥ ê°œì¥ ì—¬ë¶€ í™•ì¸"""
    pass

def has_active_positions() -> bool:
    """í™œì„± í¬ì§€ì…˜ ì¡´ì¬ ì—¬ë¶€"""
    pass

def can_execute_order(order: Order) -> bool:
    """ì£¼ë¬¸ ì‹¤í–‰ ê°€ëŠ¥ ì—¬ë¶€"""
    pass
```

### 3.2 í´ë˜ìŠ¤ëª…

**ëª…ì‚¬ ì‚¬ìš©, PascalCase**
```python
# âœ… í´ë˜ìŠ¤ëª…ì€ ëª…ì‚¬ë¡œ, ì—­í• ì„ ëª…í™•íˆ í‘œí˜„
class TradingEngine:
    """ê±°ë˜ ì—”ì§„"""
    pass

class MarketDataProvider:
    """ì‹œì¥ ë°ì´í„° ì œê³µì"""
    pass

class RiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ì"""
    pass

class OrderExecutor:
    """ì£¼ë¬¸ ì‹¤í–‰ì"""
    pass
```

### 3.3 ìƒìˆ˜ëª…

**ëŒ€ë¬¸ì + ì–¸ë”ìŠ¤ì½”ì–´**
```python
# âœ… ìƒìˆ˜ëŠ” ëŒ€ë¬¸ìë¡œ ëª…ëª…
MAX_POSITION_SIZE = 1000.0
DEFAULT_LEVERAGE = 10
API_TIMEOUT_SECONDS = 30
WEBSOCKET_RECONNECT_DELAY = 5

# ì„¤ì • ê·¸ë£¹í™”
class TradingConfig:
    MAX_POSITIONS = 5
    DEFAULT_STOP_LOSS_PERCENTAGE = 0.02
    DEFAULT_TAKE_PROFIT_PERCENTAGE = 0.04
    ORDER_TIMEOUT_SECONDS = 60
```

---

## ğŸ”§ 4. í•¨ìˆ˜ ì„¤ê³„ ì›ì¹™

### 4.1 í•¨ìˆ˜ í¬ê¸° ë° ë³µì¡ì„±

**ì‘ê³  ë‹¨ìˆœí•œ í•¨ìˆ˜**
```python
# âŒ ë‚˜ìœ ì˜ˆ: ë„ˆë¬´ ê¸´ í•¨ìˆ˜
def process_trading_signals(market_data):
    # 50ì¤„ ì´ìƒì˜ ë³µì¡í•œ ë¡œì§...
    pass

# âœ… ì¢‹ì€ ì˜ˆ: ì‘ê³  ëª…í™•í•œ í•¨ìˆ˜ë“¤ë¡œ ë¶„ë¦¬
def calculate_moving_average(prices: List[float], period: int) -> float:
    """ì´ë™í‰ê·  ê³„ì‚°"""
    if len(prices) < period:
        raise ValueError(f"Insufficient data: need {period}, got {len(prices)}")
    
    return sum(prices[-period:]) / period

def evaluate_ma_condition(current_price: float, ma_value: float, condition_type: str) -> Optional[Signal]:
    """ì´ë™í‰ê·  ì¡°ê±´ í‰ê°€"""
    if condition_type == "close_above" and current_price > ma_value:
        return Signal("BUY", current_price, confidence=0.8)
    elif condition_type == "close_below" and current_price < ma_value:
        return Signal("SELL", current_price, confidence=0.8)
    
    return None

def process_ma_signals(market_data: MarketData, ma_config: MAConfig) -> List[Signal]:
    """ì´ë™í‰ê·  ì‹ í˜¸ ì²˜ë¦¬"""
    signals = []
    
    for config in ma_config.conditions:
        ma_value = calculate_moving_average(market_data.close_prices, config.period)
        signal = evaluate_ma_condition(market_data.current_price, ma_value, config.type)
        
        if signal:
            signals.append(signal)
    
    return signals
```

### 4.2 ë§¤ê°œë³€ìˆ˜ ê´€ë¦¬

**ë§¤ê°œë³€ìˆ˜ ê°œìˆ˜ ì œí•œ (ìµœëŒ€ 3-4ê°œ)**
```python
# âŒ ë‚˜ìœ ì˜ˆ: ë§¤ê°œë³€ìˆ˜ê°€ ë„ˆë¬´ ë§ìŒ
def create_order(symbol, side, quantity, order_type, price, stop_price, time_in_force, reduce_only, close_position):
    pass

# âœ… ì¢‹ì€ ì˜ˆ: ê°ì²´ë¡œ ê·¸ë£¹í™”
@dataclass
class OrderParams:
    symbol: str
    side: str  # "BUY" or "SELL"
    quantity: float
    order_type: str = "MARKET"
    price: Optional[float] = None
    stop_price: Optional[float] = None
    time_in_force: str = "GTC"
    reduce_only: bool = False
    close_position: bool = False

def create_order(params: OrderParams) -> Order:
    """ì£¼ë¬¸ ìƒì„±"""
    return Order(
        symbol=params.symbol,
        side=params.side,
        quantity=params.quantity,
        order_type=params.order_type,
        price=params.price,
        stop_price=params.stop_price,
        time_in_force=params.time_in_force,
        reduce_only=params.reduce_only,
        close_position=params.close_position
    )
```

### 4.3 ë°˜í™˜ê°’ ê´€ë¦¬

**ëª…í™•í•œ ë°˜í™˜ íƒ€ì…**
```python
from typing import Union, Optional, Tuple, List
from dataclasses import dataclass

# âœ… ëª…í™•í•œ ë°˜í™˜ íƒ€ì… ì •ì˜
@dataclass
class ValidationResult:
    is_valid: bool
    error_message: Optional[str] = None
    warnings: List[str] = None

def validate_order(order: Order) -> ValidationResult:
    """ì£¼ë¬¸ ê²€ì¦"""
    warnings = []
    
    # ê¸°ë³¸ ê²€ì¦
    if order.quantity <= 0:
        return ValidationResult(False, "Quantity must be positive")
    
    if order.symbol not in SUPPORTED_SYMBOLS:
        return ValidationResult(False, f"Unsupported symbol: {order.symbol}")
    
    # ê²½ê³  ì‚¬í•­ ì²´í¬
    if order.quantity > MAX_POSITION_SIZE:
        warnings.append(f"Large position size: {order.quantity}")
    
    return ValidationResult(True, warnings=warnings)

# ì‚¬ìš© ì˜ˆì‹œ
result = validate_order(order)
if not result.is_valid:
    logger.error(f"Order validation failed: {result.error_message}")
    return

if result.warnings:
    for warning in result.warnings:
        logger.warning(warning)
```

---

## ğŸ›ï¸ 5. í´ë˜ìŠ¤ ì„¤ê³„ ì›ì¹™

### 5.1 ìº¡ìŠí™” (Encapsulation)

**private ë©¤ë²„ ì‚¬ìš©**
```python
class Position:
    """í¬ì§€ì…˜ í´ë˜ìŠ¤"""
    
    def __init__(self, symbol: str, side: str, quantity: float, entry_price: float):
        self.symbol = symbol
        self.side = side
        self._quantity = quantity  # protected
        self._entry_price = entry_price  # protected
        self.__created_at = datetime.utcnow()  # private
        self.__pnl_cache = None  # private
    
    @property
    def quantity(self) -> float:
        """ìˆ˜ëŸ‰ ì¡°íšŒ"""
        return self._quantity
    
    @quantity.setter
    def quantity(self, value: float) -> None:
        """ìˆ˜ëŸ‰ ì„¤ì • - ê²€ì¦ ë¡œì§ í¬í•¨"""
        if value <= 0:
            raise ValueError("Quantity must be positive")
        
        self._quantity = value
        self.__pnl_cache = None  # ìºì‹œ ë¬´íš¨í™”
    
    @property
    def entry_price(self) -> float:
        """ì§„ì…ê°€ ì¡°íšŒ"""
        return self._entry_price
    
    def calculate_pnl(self, current_price: float) -> float:
        """ì†ìµ ê³„ì‚° - ìºì‹œ í™œìš©"""
        cache_key = current_price
        if self.__pnl_cache and self.__pnl_cache[0] == cache_key:
            return self.__pnl_cache[1]
        
        if self.side == "BUY":
            pnl = (current_price - self._entry_price) * self._quantity
        else:  # SELL
            pnl = (self._entry_price - current_price) * self._quantity
        
        self.__pnl_cache = (cache_key, pnl)
        return pnl
    
    def __str__(self) -> str:
        """ë¬¸ìì—´ í‘œí˜„"""
        return f"Position({self.symbol}, {self.side}, {self._quantity}@{self._entry_price})"
```

### 5.2 ìƒì† vs ì»´í¬ì§€ì…˜

**ì»´í¬ì§€ì…˜ ìš°ì„  ì‚¬ìš©**
```python
# âœ… ì»´í¬ì§€ì…˜ì„ í†µí•œ ìœ ì—°í•œ ì„¤ê³„
class TradingStrategy:
    """ê±°ë˜ ì „ëµ - ì»´í¬ì§€ì…˜ í™œìš©"""
    
    def __init__(self, 
                 entry_conditions: List[EntryCondition],
                 exit_conditions: List[ExitCondition],
                 risk_manager: RiskManager):
        self.entry_conditions = entry_conditions
        self.exit_conditions = exit_conditions
        self.risk_manager = risk_manager
        self.positions = []
    
    def add_entry_condition(self, condition: EntryCondition) -> None:
        """ì§„ì… ì¡°ê±´ ì¶”ê°€"""
        self.entry_conditions.append(condition)
    
    def remove_entry_condition(self, condition: EntryCondition) -> None:
        """ì§„ì… ì¡°ê±´ ì œê±°"""
        if condition in self.entry_conditions:
            self.entry_conditions.remove(condition)
    
    def evaluate_entry_signals(self, market_data: MarketData) -> List[Signal]:
        """ì§„ì… ì‹ í˜¸ í‰ê°€"""
        signals = []
        
        for condition in self.entry_conditions:
            if condition.is_active():
                signal = condition.evaluate(market_data)
                if signal and self.risk_manager.validate_signal(signal):
                    signals.append(signal)
        
        return signals

# ì‚¬ìš© ì˜ˆì‹œ - ëŸ°íƒ€ì„ì— ì „ëµ êµ¬ì„± ë³€ê²½ ê°€ëŠ¥
strategy = TradingStrategy(
    entry_conditions=[
        MovingAverageCondition(20, "close_above"),
        PriceChannelCondition("upper_breakout")
    ],
    exit_conditions=[
        PCSExitCondition([1, 2, 3]),
        TrailingStopCondition(10)
    ],
    risk_manager=RiskManager(max_positions=5)
)

# ëŸ°íƒ€ì„ì— ì¡°ê±´ ì¶”ê°€/ì œê±°
strategy.add_entry_condition(OrderBookCondition(5))
strategy.remove_entry_condition(existing_condition)
```

---

## ğŸ” 6. ì˜¤ë¥˜ ì²˜ë¦¬

### 6.1 ì˜ˆì™¸ ê³„ì¸µ êµ¬ì¡°

**ë„ë©”ì¸ë³„ ì˜ˆì™¸ ì •ì˜**
```python
# ê¸°ë³¸ ì˜ˆì™¸ í´ë˜ìŠ¤
class TradingSystemError(Exception):
    """ê±°ë˜ ì‹œìŠ¤í…œ ê¸°ë³¸ ì˜ˆì™¸"""
    
    def __init__(self, message: str, error_code: str = None, details: dict = None):
        super().__init__(message)
        self.message = message
        self.error_code = error_code
        self.details = details or {}
        self.timestamp = datetime.utcnow()

# ë„ë©”ì¸ë³„ ì˜ˆì™¸
class APIError(TradingSystemError):
    """API ê´€ë ¨ ì˜ˆì™¸"""
    pass

class InsufficientBalanceError(TradingSystemError):
    """ì”ê³  ë¶€ì¡± ì˜ˆì™¸"""
    pass

class InvalidOrderError(TradingSystemError):
    """ì˜ëª»ëœ ì£¼ë¬¸ ì˜ˆì™¸"""
    pass

class RiskLimitExceededError(TradingSystemError):
    """ë¦¬ìŠ¤í¬ í•œë„ ì´ˆê³¼ ì˜ˆì™¸"""
    pass

class MarketDataError(TradingSystemError):
    """ì‹œì¥ ë°ì´í„° ì˜¤ë¥˜"""
    pass

# êµ¬ì²´ì ì¸ ì˜ˆì™¸ë“¤
class BinanceAPIError(APIError):
    """ë°”ì´ë‚¸ìŠ¤ API ì˜¤ë¥˜"""
    
    def __init__(self, message: str, api_code: int, api_message: str):
        super().__init__(
            message=message,
            error_code=f"BINANCE_{api_code}",
            details={"api_code": api_code, "api_message": api_message}
        )

class BybitAPIError(APIError):
    """ë°”ì´ë¹„íŠ¸ API ì˜¤ë¥˜"""
    
    def __init__(self, message: str, ret_code: int, ret_msg: str):
        super().__init__(
            message=message,
            error_code=f"BYBIT_{ret_code}",
            details={"ret_code": ret_code, "ret_msg": ret_msg}
        )
```

### 6.2 ì˜ˆì™¸ ì²˜ë¦¬ íŒ¨í„´

**ê³„ì¸µë³„ ì˜ˆì™¸ ì²˜ë¦¬**
```python
class OrderExecutor:
    """ì£¼ë¬¸ ì‹¤í–‰ì"""
    
    async def execute_order(self, order: Order) -> OrderResult:
        """ì£¼ë¬¸ ì‹¤í–‰ - ê³„ì¸µë³„ ì˜ˆì™¸ ì²˜ë¦¬"""
        try:
            # 1. ì£¼ë¬¸ ê²€ì¦
            validation_result = self._validate_order(order)
            if not validation_result.is_valid:
                raise InvalidOrderError(
                    f"Order validation failed: {validation_result.error_message}",
                    error_code="INVALID_ORDER",
                    details={"order": order.to_dict()}
                )
            
            # 2. ì”ê³  í™•ì¸
            required_balance = self._calculate_required_balance(order)
            if not await self._check_balance(required_balance):
                raise InsufficientBalanceError(
                    f"Insufficient balance: required {required_balance}",
                    error_code="INSUFFICIENT_BALANCE",
                    details={"required": required_balance, "order": order.to_dict()}
                )
            
            # 3. API í˜¸ì¶œ
            result = await self._place_order_via_api(order)
            return result
            
        except InvalidOrderError:
            # ì£¼ë¬¸ ì˜¤ë¥˜ëŠ” ê·¸ëŒ€ë¡œ ì „íŒŒ
            raise
        except InsufficientBalanceError:
            # ì”ê³  ë¶€ì¡±ë„ ê·¸ëŒ€ë¡œ ì „íŒŒ
            raise
        except APIError as e:
            # API ì˜¤ë¥˜ëŠ” ë¡œê¹… í›„ ì¬ì‹œë„ ë˜ëŠ” ì „íŒŒ
            logger.error(f"API error during order execution: {e}")
            if self._should_retry(e):
                return await self._retry_order_execution(order)
            raise
        except Exception as e:
            # ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ëŠ” ë˜í•‘í•´ì„œ ì „íŒŒ
            logger.error(f"Unexpected error during order execution: {e}")
            raise TradingSystemError(
                f"Order execution failed: {str(e)}",
                error_code="ORDER_EXECUTION_FAILED",
                details={"order": order.to_dict(), "original_error": str(e)}
            )
    
    async def _retry_order_execution(self, order: Order, max_retries: int = 3) -> OrderResult:
        """ì£¼ë¬¸ ì‹¤í–‰ ì¬ì‹œë„"""
        for attempt in range(max_retries):
            try:
                await asyncio.sleep(2 ** attempt)  # ì§€ìˆ˜ ë°±ì˜¤í”„
                result = await self._place_order_via_api(order)
                logger.info(f"Order execution succeeded on retry {attempt + 1}")
                return result
            except APIError as e:
                if attempt == max_retries - 1:  # ë§ˆì§€ë§‰ ì‹œë„
                    raise
                logger.warning(f"Retry {attempt + 1} failed: {e}")
```

### 6.3 ë¡œê¹…ê³¼ ëª¨ë‹ˆí„°ë§

**êµ¬ì¡°í™”ëœ ë¡œê¹…**
```python
import logging
import json
from datetime import datetime
from typing import Any, Dict

class StructuredLogger:
    """êµ¬ì¡°í™”ëœ ë¡œê¹…"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self._setup_logger()
    
    def _setup_logger(self):
        """ë¡œê±° ì„¤ì •"""
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
    
    def _log_structured(self, level: str, message: str, **kwargs):
        """êµ¬ì¡°í™”ëœ ë¡œê·¸ ì¶œë ¥"""
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": level,
            "message": message,
            **kwargs
        }
        
        getattr(self.logger, level.lower())(json.dumps(log_data, default=str))
    
    def info(self, message: str, **kwargs):
        """ì •ë³´ ë¡œê·¸"""
        self._log_structured("INFO", message, **kwargs)
    
    def error(self, message: str, **kwargs):
        """ì˜¤ë¥˜ ë¡œê·¸"""
        self._log_structured("ERROR", message, **kwargs)
    
    def warning(self, message: str, **kwargs):
        """ê²½ê³  ë¡œê·¸"""
        self._log_structured("WARNING", message, **kwargs)

# ì‚¬ìš© ì˜ˆì‹œ
logger = StructuredLogger("trading_engine")

# ì£¼ë¬¸ ì‹¤í–‰ ë¡œê·¸
logger.info(
    "Order executed successfully",
    order_id="12345",
    symbol="BTCUSDT",
    side="BUY",
    quantity=0.1,
    price=50000.0,
    execution_time_ms=150
)

# ì˜¤ë¥˜ ë¡œê·¸
logger.error(
    "Order execution failed",
    order_id="12346",
    symbol="ETHUSDT",
    error_code="INSUFFICIENT_BALANCE",
    error_message="Insufficient balance for order",
    required_balance=1000.0,
    available_balance=500.0
)
```

---

## âš¡ 7. ì„±ëŠ¥ ìµœì í™”

### 7.1 ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°

**asyncio í™œìš©**
```python
import asyncio
import aiohttp
from typing import List, Dict, Any

class AsyncMarketDataProvider:
    """ë¹„ë™ê¸° ì‹œì¥ ë°ì´í„° ì œê³µì"""
    
    def __init__(self):
        self.session = None
        self._data_cache = {}
        self._cache_ttl = 1  # 1ì´ˆ ìºì‹œ
    
    async def __aenter__(self):
        """ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì§„ì…"""
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì¢…ë£Œ"""
        if self.session:
            await self.session.close()
    
    async def get_multiple_tickers(self, symbols: List[str]) -> Dict[str, Dict[str, Any]]:
        """ì—¬ëŸ¬ ì‹¬ë³¼ì˜ í‹°ì»¤ ë°ì´í„° ë™ì‹œ ì¡°íšŒ"""
        tasks = [self._get_ticker(symbol) for symbol in symbols]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        ticker_data = {}
        for symbol, result in zip(symbols, results):
            if isinstance(result, Exception):
                logger.error(f"Failed to get ticker for {symbol}: {result}")
                continue
            ticker_data[symbol] = result
        
        return ticker_data
    
    async def _get_ticker(self, symbol: str) -> Dict[str, Any]:
        """ë‹¨ì¼ ì‹¬ë³¼ í‹°ì»¤ ì¡°íšŒ - ìºì‹œ í™œìš©"""
        cache_key = f"ticker_{symbol}"
        cached_data = self._get_cached_data(cache_key)
        
        if cached_data:
            return cached_data
        
        url = f"https://fapi.binance.com/fapi/v1/ticker/24hr?symbol={symbol}"
        
        async with self.session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                self._cache_data(cache_key, data)
                return data
            else:
                raise APIError(f"Failed to get ticker for {symbol}: {response.status}")
    
    def _get_cached_data(self, key: str) -> Optional[Dict[str, Any]]:
        """ìºì‹œ ë°ì´í„° ì¡°íšŒ"""
        if key in self._data_cache:
            cached_time, data = self._data_cache[key]
            if time.time() - cached_time < self._cache_ttl:
                return data
        return None
    
    def _cache_data(self, key: str, data: Dict[str, Any]) -> None:
        """ë°ì´í„° ìºì‹œ"""
        self._data_cache[key] = (time.time(), data)

# ì‚¬ìš© ì˜ˆì‹œ
async def main():
    symbols = ["BTCUSDT", "ETHUSDT", "ADAUSDT", "DOTUSDT"]
    
    async with AsyncMarketDataProvider() as provider:
        ticker_data = await provider.get_multiple_tickers(symbols)
        
        for symbol, data in ticker_data.items():
            print(f"{symbol}: {data['lastPrice']}")

# ì‹¤í–‰
asyncio.run(main())
```

### 7.2 ë©”ëª¨ë¦¬ ìµœì í™”

**ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°ì´í„° êµ¬ì¡°**
```python
from dataclasses import dataclass
from typing import NamedTuple
import sys

# âŒ ë©”ëª¨ë¦¬ ë¹„íš¨ìœ¨ì 
class MarketDataDict:
    def __init__(self, symbol, price, volume, timestamp):
        self.symbol = symbol
        self.price = price
        self.volume = volume
        self.timestamp = timestamp

# âœ… ë©”ëª¨ë¦¬ íš¨ìœ¨ì  - NamedTuple ì‚¬ìš©
class MarketData(NamedTuple):
    symbol: str
    price: float
    volume: float
    timestamp: int

# âœ… ë©”ëª¨ë¦¬ íš¨ìœ¨ì  - dataclass with slots
@dataclass(frozen=True)
class OptimizedMarketData:
    __slots__ = ['symbol', 'price', 'volume', 'timestamp']
    
    symbol: str
    price: float
    volume: float
    timestamp: int

# ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¹„êµ
data_dict = MarketDataDict("BTCUSDT", 50000.0, 1000.0, 1234567890)
data_tuple = MarketData("BTCUSDT", 50000.0, 1000.0, 1234567890)
data_optimized = OptimizedMarketData("BTCUSDT", 50000.0, 1000.0, 1234567890)

print(f"Dict size: {sys.getsizeof(data_dict)} bytes")
print(f"NamedTuple size: {sys.getsizeof(data_tuple)} bytes")
print(f"Optimized dataclass size: {sys.getsizeof(data_optimized)} bytes")
```

### 7.3 ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”

**íš¨ìœ¨ì ì¸ ì¿¼ë¦¬ ë° ì¸ë±ì‹±**
```python
import sqlite3
from typing import List, Optional
from contextlib import contextmanager

class TradingDatabase:
    """ê±°ë˜ ë°ì´í„°ë² ì´ìŠ¤ - ìµœì í™”ëœ ì¿¼ë¦¬"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
        self._init_database()
    
    def _init_database(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”"""
        with self._get_connection() as conn:
            # í…Œì´ë¸” ìƒì„±
            conn.execute("""
                CREATE TABLE IF NOT EXISTS trades (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    side TEXT NOT NULL,
                    quantity REAL NOT NULL,
                    price REAL NOT NULL,
                    timestamp INTEGER NOT NULL,
                    order_id TEXT UNIQUE NOT NULL
                )
            """)
            
            # ì¸ë±ìŠ¤ ìƒì„± - ìì£¼ ì¡°íšŒë˜ëŠ” ì»¬ëŸ¼
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol ON trades(symbol)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_timestamp ON trades(timestamp)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_order_id ON trades(order_id)")
            
            # ë³µí•© ì¸ë±ìŠ¤ - í•¨ê»˜ ì¡°íšŒë˜ëŠ” ì»¬ëŸ¼ë“¤
            conn.execute("CREATE INDEX IF NOT EXISTS idx_trades_symbol_timestamp ON trades(symbol, timestamp)")
    
    @contextmanager
    def _get_connection(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì €"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row  # ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ê²°ê³¼ ë°˜í™˜
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def insert_trade(self, trade_data: Dict[str, Any]) -> int:
        """ê±°ë˜ ë°ì´í„° ì‚½ì… - ë°°ì¹˜ ì²˜ë¦¬ ì§€ì›"""
        with self._get_connection() as conn:
            cursor = conn.execute("""
                INSERT INTO trades (symbol, side, quantity, price, timestamp, order_id)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                trade_data['symbol'],
                trade_data['side'],
                trade_data['quantity'],
                trade_data['price'],
                trade_data['timestamp'],
                trade_data['order_id']
            ))
            return cursor.lastrowid
    
    def insert_trades_batch(self, trades_data: List[Dict[str, Any]]) -> None:
        """ê±°ë˜ ë°ì´í„° ë°°ì¹˜ ì‚½ì… - ì„±ëŠ¥ ìµœì í™”"""
        with self._get_connection() as conn:
            conn.executemany("""
                INSERT INTO trades (symbol, side, quantity, price, timestamp, order_id)
                VALUES (?, ?, ?, ?, ?, ?)
            """, [
                (
                    trade['symbol'],
                    trade['side'],
                    trade['quantity'],
                    trade['price'],
                    trade['timestamp'],
                    trade['order_id']
                )
                for trade in trades_data
            ])
    
    def get_trades_by_symbol(self, symbol: str, limit: int = 100) -> List[Dict[str, Any]]:
        """ì‹¬ë³¼ë³„ ê±°ë˜ ì¡°íšŒ - ì¸ë±ìŠ¤ í™œìš©"""
        with self._get_connection() as conn:
            cursor = conn.execute("""
                SELECT * FROM trades 
                WHERE symbol = ? 
                ORDER BY timestamp DESC 
                LIMIT ?
            """, (symbol, limit))
            
            return [dict(row) for row in cursor.fetchall()]
    
    def get_trades_in_period(self, symbol: str, start_time: int, end_time: int) -> List[Dict[str, Any]]:
        """ê¸°ê°„ë³„ ê±°ë˜ ì¡°íšŒ - ë³µí•© ì¸ë±ìŠ¤ í™œìš©"""
        with self._get_connection() as conn:
            cursor = conn.execute("""
                SELECT * FROM trades 
                WHERE symbol = ? AND timestamp BETWEEN ? AND ?
                ORDER BY timestamp ASC
            """, (symbol, start_time, end_time))
            
            return [dict(row) for row in cursor.fetchall()]
```

---

## ğŸ§ª 8. í…ŒìŠ¤íŠ¸ ì‘ì„± ê°€ì´ë“œ

### 8.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

**í…ŒìŠ¤íŠ¸ êµ¬ì¡° ë° ë„¤ì´ë°**
```python
import pytest
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime, timedelta

class TestTradingEngine:
    """ê±°ë˜ ì—”ì§„ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤"""
    
    @pytest.fixture
    def mock_market_data(self):
        """ëª¨ì˜ ì‹œì¥ ë°ì´í„° í”½ìŠ¤ì²˜"""
        return MarketData(
            symbol="BTCUSDT",
            price=50000.0,
            volume=1000.0,
            timestamp=int(datetime.utcnow().timestamp())
        )
    
    @pytest.fixture
    def trading_engine(self):
        """ê±°ë˜ ì—”ì§„ í”½ìŠ¤ì²˜"""
        config = TradingConfig(
            max_positions=5,
            default_quantity=0.1,
            risk_percentage=0.02
        )
        return TradingEngine(config)
    
    def test_should_generate_buy_signal_when_price_above_moving_average(self, trading_engine, mock_market_data):
        """ì´ë™í‰ê·  ìœ„ì—ì„œ ë§¤ìˆ˜ ì‹ í˜¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        # Given
        ma_condition = MovingAverageCondition(period=20, condition_type="close_above")
        trading_engine.add_entry_condition(ma_condition)
        
        # ì´ë™í‰ê· ë³´ë‹¤ ë†’ì€ ê°€ê²© ì„¤ì •
        mock_market_data = mock_market_data._replace(price=51000.0)
        
        with patch.object(ma_condition, '_calculate_moving_average', return_value=50000.0):
            # When
            signals = trading_engine.evaluate_entry_signals(mock_market_data)
            
            # Then
            assert len(signals) == 1
            assert signals[0].signal_type == "BUY"
            assert signals[0].price == 51000.0
            assert signals[0].confidence > 0.7
    
    def test_should_not_generate_signal_when_condition_inactive(self, trading_engine, mock_market_data):
        """ë¹„í™œì„± ì¡°ê±´ì—ì„œ ì‹ í˜¸ ë¯¸ìƒì„± í…ŒìŠ¤íŠ¸"""
        # Given
        ma_condition = MovingAverageCondition(period=20, condition_type="close_above")
        ma_condition.deactivate()  # ì¡°ê±´ ë¹„í™œì„±í™”
        trading_engine.add_entry_condition(ma_condition)
        
        # When
        signals = trading_engine.evaluate_entry_signals(mock_market_data)
        
        # Then
        assert len(signals) == 0
    
    @pytest.mark.asyncio
    async def test_should_handle_api_error_gracefully(self, trading_engine):
        """API ì˜¤ë¥˜ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        # Given
        order = Order("BTCUSDT", "BUY", 0.1, "MARKET")
        
        with patch.object(trading_engine.order_executor, 'execute_order') as mock_execute:
            mock_execute.side_effect = BinanceAPIError("Insufficient balance", -2010, "Account has insufficient balance")
            
            # When & Then
            with pytest.raises(InsufficientBalanceError):
                await trading_engine.execute_order(order)
    
    def test_should_calculate_position_size_correctly(self, trading_engine):
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° í…ŒìŠ¤íŠ¸"""
        # Given
        account_balance = 10000.0
        risk_percentage = 0.02  # 2%
        entry_price = 50000.0
        stop_loss_price = 49000.0
        
        # When
        position_size = trading_engine.calculate_position_size(
            account_balance, risk_percentage, entry_price, stop_loss_price
        )
        
        # Then
        expected_risk_amount = account_balance * risk_percentage  # 200
        expected_loss_per_unit = entry_price - stop_loss_price  # 1000
        expected_position_size = expected_risk_amount / expected_loss_per_unit  # 0.2
        
        assert abs(position_size - expected_position_size) < 0.001

class TestRiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def risk_manager(self):
        """ë¦¬ìŠ¤í¬ ê´€ë¦¬ì í”½ìŠ¤ì²˜"""
        config = RiskConfig(
            max_positions=3,
            max_risk_per_trade=0.02,
            max_total_risk=0.06,
            max_drawdown=0.10
        )
        return RiskManager(config)
    
    def test_should_reject_order_when_max_positions_exceeded(self, risk_manager):
        """ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼ ì‹œ ì£¼ë¬¸ ê±°ë¶€ í…ŒìŠ¤íŠ¸"""
        # Given - ì´ë¯¸ 3ê°œ í¬ì§€ì…˜ ì¡´ì¬
        existing_positions = [
            Position("BTCUSDT", "BUY", 0.1, 50000),
            Position("ETHUSDT", "BUY", 1.0, 3000),
            Position("ADAUSDT", "BUY", 1000, 1.0)
        ]
        
        for position in existing_positions:
            risk_manager.add_position(position)
        
        new_order = Order("DOTUSDT", "BUY", 100, "MARKET")
        
        # When
        result = risk_manager.validate_order(new_order)
        
        # Then
        assert not result.is_valid
        assert "maximum positions" in result.error_message.lower()
    
    def test_should_allow_closing_order_when_max_positions_exceeded(self, risk_manager):
        """ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼ ìƒí™©ì—ì„œ ì²­ì‚° ì£¼ë¬¸ í—ˆìš© í…ŒìŠ¤íŠ¸"""
        # Given - ì´ë¯¸ 3ê°œ í¬ì§€ì…˜ ì¡´ì¬
        existing_positions = [
            Position("BTCUSDT", "BUY", 0.1, 50000),
            Position("ETHUSDT", "BUY", 1.0, 3000),
            Position("ADAUSDT", "BUY", 1000, 1.0)
        ]
        
        for position in existing_positions:
            risk_manager.add_position(position)
        
        # ê¸°ì¡´ í¬ì§€ì…˜ ì²­ì‚° ì£¼ë¬¸
        closing_order = Order("BTCUSDT", "SELL", 0.1, "MARKET", reduce_only=True)
        
        # When
        result = risk_manager.validate_order(closing_order)
        
        # Then
        assert result.is_valid
```

### 8.2 í†µí•© í…ŒìŠ¤íŠ¸

**ì‹¤ì œ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸**
```python
@pytest.mark.integration
class TestTradingSystemIntegration:
    """ê±°ë˜ ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    async def trading_system(self):
        """í†µí•© í…ŒìŠ¤íŠ¸ìš© ê±°ë˜ ì‹œìŠ¤í…œ"""
        # í…ŒìŠ¤íŠ¸ìš© ì„¤ì •
        config = TradingConfig(
            api_key="test_key",
            api_secret="test_secret",
            testnet=True,  # í…ŒìŠ¤íŠ¸ë„· ì‚¬ìš©
            max_positions=3
        )
        
        system = TradingSystem(config)
        await system.initialize()
        
        yield system
        
        await system.shutdown()
    
    @pytest.mark.asyncio
    async def test_complete_trading_cycle(self, trading_system):
        """ì™„ì „í•œ ê±°ë˜ ì‚¬ì´í´ í…ŒìŠ¤íŠ¸"""
        # Given
        symbol = "BTCUSDT"
        
        # 1. ì‹œì¥ ë°ì´í„° ìˆ˜ì‹  í™•ì¸
        market_data = await trading_system.get_market_data(symbol)
        assert market_data is not None
        assert market_data.symbol == symbol
        
        # 2. ì§„ì… ì‹ í˜¸ ìƒì„±
        signals = trading_system.evaluate_entry_signals(market_data)
        
        if signals:
            signal = signals[0]
            
            # 3. ì£¼ë¬¸ ì‹¤í–‰
            order_result = await trading_system.execute_order(signal)
            assert order_result.status == "FILLED"
            
            # 4. í¬ì§€ì…˜ í™•ì¸
            positions = trading_system.get_active_positions()
            assert len(positions) > 0
            
            position = next(p for p in positions if p.symbol == symbol)
            assert position.side == signal.signal_type
            
            # 5. ì²­ì‚° ì‹ í˜¸ ëŒ€ê¸° (ì‹œë®¬ë ˆì´ì…˜)
            # ì‹¤ì œë¡œëŠ” ì‹œê°„ì´ ê±¸ë¦¬ë¯€ë¡œ ëª¨ì˜ ë°ì´í„° ì‚¬ìš©
            exit_price = market_data.price * 1.02 if signal.signal_type == "BUY" else market_data.price * 0.98
            exit_signal = Signal("SELL" if signal.signal_type == "BUY" else "BUY", exit_price, 0.9)
            
            # 6. ì²­ì‚° ì‹¤í–‰
            exit_result = await trading_system.execute_order(exit_signal)
            assert exit_result.status == "FILLED"
            
            # 7. í¬ì§€ì…˜ ì •ë¦¬ í™•ì¸
            updated_positions = trading_system.get_active_positions()
            remaining_position = next((p for p in updated_positions if p.symbol == symbol), None)
            assert remaining_position is None or remaining_position.quantity == 0
    
    @pytest.mark.asyncio
    async def test_risk_management_integration(self, trading_system):
        """ë¦¬ìŠ¤í¬ ê´€ë¦¬ í†µí•© í…ŒìŠ¤íŠ¸"""
        # Given - ê³„ì • ì”ê³  ì¡°íšŒ
        account_info = await trading_system.get_account_info()
        initial_balance = account_info.total_balance
        
        # í° í¬ì§€ì…˜ ì£¼ë¬¸ ì‹œë„ (ë¦¬ìŠ¤í¬ í•œë„ ì´ˆê³¼)
        large_quantity = initial_balance * 10  # ì”ê³ ì˜ 10ë°°
        large_order = Order("BTCUSDT", "BUY", large_quantity, "MARKET")
        
        # When & Then
        with pytest.raises(RiskLimitExceededError):
            await trading_system.execute_order_from_params(large_order)
    
    @pytest.mark.asyncio
    async def test_api_error_recovery(self, trading_system):
        """API ì˜¤ë¥˜ ë³µêµ¬ í…ŒìŠ¤íŠ¸"""
        # Given - API ì—°ê²° ê°•ì œ ì¢…ë£Œ
        await trading_system.api_connector.disconnect()
        
        # When - ì‹œì¥ ë°ì´í„° ìš”ì²­ (ì¬ì—°ê²° ì‹œë„)
        market_data = await trading_system.get_market_data("BTCUSDT")
        
        # Then - ì¬ì—°ê²° í›„ ì •ìƒ ë°ì´í„° ìˆ˜ì‹ 
        assert market_data is not None
        assert trading_system.api_connector.is_connected()
```

### 8.3 ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

**ë²¤ì¹˜ë§ˆí¬ ë° ë¶€í•˜ í…ŒìŠ¤íŠ¸**
```python
import time
import asyncio
from concurrent.futures import ThreadPoolExecutor

@pytest.mark.performance
class TestPerformance:
    """ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    
    def test_signal_calculation_performance(self, benchmark):
        """ì‹ í˜¸ ê³„ì‚° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        # Given
        trading_engine = TradingEngine(TradingConfig())
        market_data = self._generate_market_data(1000)  # 1000ê°œ ë°ì´í„° í¬ì¸íŠ¸
        
        # When & Then
        result = benchmark(trading_engine.evaluate_entry_signals, market_data)
        
        # ì„±ëŠ¥ ê¸°ì¤€: 10ms ì´í•˜
        assert benchmark.stats['mean'] < 0.01
    
    @pytest.mark.asyncio
    async def test_concurrent_order_processing(self):
        """ë™ì‹œ ì£¼ë¬¸ ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        trading_system = TradingSystem(TradingConfig())
        
        # 100ê°œ ë™ì‹œ ì£¼ë¬¸ ìƒì„±
        orders = [
            Order(f"BTC{i}USDT", "BUY", 0.001, "MARKET")
            for i in range(100)
        ]
        
        start_time = time.time()
        
        # ë™ì‹œ ì‹¤í–‰
        tasks = [trading_system.execute_order_simulation(order) for order in orders]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        end_time = time.time()
        execution_time = end_time - start_time
        
        # ì„±ëŠ¥ ê¸°ì¤€: 100ê°œ ì£¼ë¬¸ì„ 5ì´ˆ ë‚´ì— ì²˜ë¦¬
        assert execution_time < 5.0
        
        # ì„±ê³µë¥  í™•ì¸
        successful_orders = [r for r in results if not isinstance(r, Exception)]
        success_rate = len(successful_orders) / len(orders)
        assert success_rate > 0.95  # 95% ì´ìƒ ì„±ê³µë¥ 
    
    def test_memory_usage_under_load(self):
        """ë¶€í•˜ ìƒí™©ì—ì„œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í…ŒìŠ¤íŠ¸"""
        import psutil
        import gc
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        trading_engine = TradingEngine(TradingConfig())
        
        # ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬
        for i in range(10000):
            market_data = MarketData(f"SYMBOL{i}", 50000.0, 1000.0, int(time.time()))
            signals = trading_engine.evaluate_entry_signals(market_data)
        
        gc.collect()  # ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
        
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = final_memory - initial_memory
        
        # ë©”ëª¨ë¦¬ ì¦ê°€ëŸ‰ì´ 100MB ì´í•˜ì—¬ì•¼ í•¨
        assert memory_increase < 100
```

---

## ğŸ“š 9. ë¬¸ì„œí™” í‘œì¤€

### 9.1 ë…ìŠ¤íŠ¸ë§ ì‘ì„±

**Google ìŠ¤íƒ€ì¼ ë…ìŠ¤íŠ¸ë§**
```python
def calculate_compound_interest(principal: float, rate: float, time: int, compound_frequency: int = 1) -> float:
    """
    ë³µë¦¬ ì´ìë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
    
    ì´ í•¨ìˆ˜ëŠ” ì£¼ì–´ì§„ ì›ê¸ˆ, ì´ìœ¨, ê¸°ê°„ì„ ë°”íƒ•ìœ¼ë¡œ ë³µë¦¬ ì´ìë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
    ë³µë¦¬ ê³„ì‚° ê³µì‹: A = P(1 + r/n)^(nt)
    
    Args:
        principal (float): ì›ê¸ˆ (ì–‘ìˆ˜ì—¬ì•¼ í•¨)
        rate (float): ì—°ì´ìœ¨ (ì†Œìˆ˜ì  í˜•íƒœ, ì˜ˆ: 0.05 = 5%)
        time (int): íˆ¬ì ê¸°ê°„ (ë…„ ë‹¨ìœ„, ì–‘ìˆ˜ì—¬ì•¼ í•¨)
        compound_frequency (int, optional): ì—°ê°„ ë³µë¦¬ ê³„ì‚° íšŸìˆ˜. ê¸°ë³¸ê°’ì€ 1 (ì—° 1íšŒ)
    
    Returns:
        float: ë³µë¦¬ ì´ìê°€ ì ìš©ëœ ìµœì¢… ê¸ˆì•¡
    
    Raises:
        ValueError: principal, rate, time ì¤‘ í•˜ë‚˜ë¼ë„ ìŒìˆ˜ì¸ ê²½ìš°
        TypeError: ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ê²½ìš°
    
    Example:
        >>> calculate_compound_interest(1000, 0.05, 10)
        1628.8946267774416
        
        >>> calculate_compound_interest(1000, 0.05, 10, 12)  # ì›”ë³µë¦¬
        1643.6194958854733
    
    Note:
        - ì´ í•¨ìˆ˜ëŠ” ì„¸ê¸ˆì´ë‚˜ ìˆ˜ìˆ˜ë£Œë¥¼ ê³ ë ¤í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
        - ì‹¤ì œ íˆ¬ì ìˆ˜ìµë¥ ì€ ì‹œì¥ ìƒí™©ì— ë”°ë¼ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤
    
    See Also:
        calculate_simple_interest: ë‹¨ë¦¬ ì´ì ê³„ì‚°
        calculate_present_value: í˜„ì¬ê°€ì¹˜ ê³„ì‚°
    """
    if principal < 0:
        raise ValueError("Principal must be non-negative")
    if rate < 0:
        raise ValueError("Rate must be non-negative")
    if time < 0:
        raise ValueError("Time must be non-negative")
    if compound_frequency <= 0:
        raise ValueError("Compound frequency must be positive")
    
    return principal * (1 + rate / compound_frequency) ** (compound_frequency * time)
```

### 9.2 í´ë˜ìŠ¤ ë¬¸ì„œí™”

**í¬ê´„ì ì¸ í´ë˜ìŠ¤ ë¬¸ì„œí™”**
```python
class TradingEngine:
    """
    ì•”í˜¸í™”í ìë™ë§¤ë§¤ ê±°ë˜ ì—”ì§„
    
    ì´ í´ë˜ìŠ¤ëŠ” ë‹¤ì–‘í•œ ì§„ì… ì¡°ê±´ê³¼ ì²­ì‚° ì¡°ê±´ì„ ê´€ë¦¬í•˜ë©°, ì‹¤ì‹œê°„ ì‹œì¥ ë°ì´í„°ë¥¼
    ê¸°ë°˜ìœ¼ë¡œ ê±°ë˜ ì‹ í˜¸ë¥¼ ìƒì„±í•˜ê³  ì£¼ë¬¸ì„ ì‹¤í–‰í•˜ëŠ” í•µì‹¬ ì—”ì§„ì…ë‹ˆë‹¤.
    
    ì£¼ìš” ê¸°ëŠ¥:
        - 5ê°€ì§€ ì§„ì… ì¡°ê±´ ì§€ì› (ì´ë™í‰ê· , Price Channel, í˜¸ê°€ê°ì§€, í‹±ê¸°ë°˜, ìº”ë“¤ìƒíƒœ)
        - 4ê°€ì§€ ì²­ì‚° ì¡°ê±´ ì§€ì› (PCS, íŠ¸ë ˆì¼ë§, í˜¸ê°€ì²­ì‚°, PCë³¸ì ˆ)
        - ì‹¤ì‹œê°„ ë¦¬ìŠ¤í¬ ê´€ë¦¬
        - ë‹¤ì¤‘ ê±°ë˜ì†Œ ì§€ì› (ë°”ì´ë‚¸ìŠ¤, ë°”ì´ë¹„íŠ¸)
    
    Attributes:
        config (TradingConfig): ê±°ë˜ ì—”ì§„ ì„¤ì •
        entry_conditions (List[EntryCondition]): í™œì„±í™”ëœ ì§„ì… ì¡°ê±´ ëª©ë¡
        exit_conditions (List[ExitCondition]): í™œì„±í™”ëœ ì²­ì‚° ì¡°ê±´ ëª©ë¡
        position_manager (PositionManager): í¬ì§€ì…˜ ê´€ë¦¬ì
        risk_manager (RiskManager): ë¦¬ìŠ¤í¬ ê´€ë¦¬ì
        api_connector (APIConnector): API ì—°ê²°ì
        is_running (bool): ì—”ì§„ ì‹¤í–‰ ìƒíƒœ
    
    Example:
        ê¸°ë³¸ ì‚¬ìš©ë²•:
        
        >>> config = TradingConfig(max_positions=5, risk_percentage=0.02)
        >>> engine = TradingEngine(config)
        >>> 
        >>> # ì§„ì… ì¡°ê±´ ì¶”ê°€
        >>> ma_condition = MovingAverageCondition(period=20, condition_type="close_above")
        >>> engine.add_entry_condition(ma_condition)
        >>> 
        >>> # ì²­ì‚° ì¡°ê±´ ì¶”ê°€
        >>> pcs_condition = PCSExitCondition(stages=[1, 2, 3])
        >>> engine.add_exit_condition(pcs_condition)
        >>> 
        >>> # ê±°ë˜ ì‹œì‘
        >>> await engine.start()
        >>> 
        >>> # ìˆ˜ë™ ì‹ í˜¸ í‰ê°€
        >>> market_data = await engine.get_market_data("BTCUSDT")
        >>> signals = engine.evaluate_entry_signals(market_data)
        >>> 
        >>> if signals:
        ...     result = await engine.execute_order(signals[0])
        ...     print(f"Order executed: {result.order_id}")
    
    Thread Safety:
        ì´ í´ë˜ìŠ¤ëŠ” ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì‚¬ìš©í•  ë•ŒëŠ”
        ì ì ˆí•œ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì„ êµ¬í˜„í•´ì•¼ í•©ë‹ˆë‹¤.
    
    Performance:
        - ì‹ í˜¸ í‰ê°€ ì‹œê°„: í‰ê·  5ms (1000ê°œ ë°ì´í„° í¬ì¸íŠ¸ ê¸°ì¤€)
        - ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ì•½ 50MB (ê¸°ë³¸ ì„¤ì •)
        - ë™ì‹œ ì²˜ë¦¬ ê°€ëŠ¥ ì‹¬ë³¼: ìµœëŒ€ 100ê°œ
    
    Version:
        1.0.0
    
    Author:
        Core Engine Agent
    
    See Also:
        TradingConfig: ê±°ë˜ ì—”ì§„ ì„¤ì • í´ë˜ìŠ¤
        EntryCondition: ì§„ì… ì¡°ê±´ ì¶”ìƒ í´ë˜ìŠ¤
        ExitCondition: ì²­ì‚° ì¡°ê±´ ì¶”ìƒ í´ë˜ìŠ¤
        RiskManager: ë¦¬ìŠ¤í¬ ê´€ë¦¬ í´ë˜ìŠ¤
    """
    
    def __init__(self, config: TradingConfig):
        """
        ê±°ë˜ ì—”ì§„ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
        
        Args:
            config (TradingConfig): ê±°ë˜ ì—”ì§„ ì„¤ì •
                - max_positions: ìµœëŒ€ ë™ì‹œ í¬ì§€ì…˜ ìˆ˜
                - risk_percentage: ê±°ë˜ë‹¹ ë¦¬ìŠ¤í¬ ë¹„ìœ¨
                - api_credentials: API ì¸ì¦ ì •ë³´
        
        Raises:
            ValueError: configê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê²½ìš°
            APIError: API ì—°ê²° ì‹¤íŒ¨ ì‹œ
        """
        self.config = config
        self.entry_conditions = []
        self.exit_conditions = []
        self.position_manager = PositionManager()
        self.risk_manager = RiskManager(config.risk_settings)
        self.api_connector = self._create_api_connector()
        self.is_running = False
        self._logger = create_logger(self.__class__.__name__)
    
    async def start(self) -> None:
        """
        ê±°ë˜ ì—”ì§„ì„ ì‹œì‘í•©ë‹ˆë‹¤.
        
        ì´ ë©”ì„œë“œëŠ” ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤:
        1. API ì—°ê²° í™•ì¸
        2. ê³„ì • ì •ë³´ ì¡°íšŒ
        3. ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì‹œì‘
        4. ê±°ë˜ ë£¨í”„ ì‹œì‘
        
        Raises:
            APIError: API ì—°ê²° ì‹¤íŒ¨ ì‹œ
            InsufficientBalanceError: ê³„ì • ì”ê³  ë¶€ì¡± ì‹œ
            TradingSystemError: ê¸°íƒ€ ì‹œìŠ¤í…œ ì˜¤ë¥˜
        
        Example:
            >>> engine = TradingEngine(config)
            >>> await engine.start()
            >>> print("Trading engine started successfully")
        """
        if self.is_running:
            self._logger.warning("Trading engine is already running")
            return
        
        try:
            # API ì—°ê²° í™•ì¸
            await self.api_connector.connect()
            
            # ê³„ì • ì •ë³´ ì¡°íšŒ
            account_info = await self.api_connector.get_account_info()
            self._logger.info(f"Account balance: {account_info.total_balance}")
            
            # ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì‹œì‘
            await self._start_data_streams()
            
            # ê±°ë˜ ë£¨í”„ ì‹œì‘
            self.is_running = True
            await self._run_trading_loop()
            
        except Exception as e:
            self._logger.error(f"Failed to start trading engine: {e}")
            await self.stop()
            raise
```

---

## ğŸ”§ 10. ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

### 10.1 ê¸°ëŠ¥ì„± ê²€í† 

**âœ… ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­**
- [ ] ëª¨ë“  ìš”êµ¬ì‚¬í•­ì´ êµ¬í˜„ë˜ì—ˆëŠ”ê°€?
- [ ] ì—£ì§€ ì¼€ì´ìŠ¤ê°€ ì ì ˆíˆ ì²˜ë¦¬ë˜ëŠ”ê°€?
- [ ] ì˜¤ë¥˜ ìƒí™©ì— ëŒ€í•œ ì²˜ë¦¬ê°€ êµ¬í˜„ë˜ì—ˆëŠ”ê°€?
- [ ] ì…ë ¥ ê²€ì¦ì´ ì¶©ë¶„í•œê°€?

**âœ… ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
- [ ] ê±°ë˜ ë¡œì§ì´ ì •í™•í•œê°€?
- [ ] ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê·œì¹™ì´ ì˜¬ë°”ë¥´ê²Œ ì ìš©ë˜ëŠ”ê°€?
- [ ] ê³„ì‚° ê³µì‹ì´ ì •í™•í•œê°€?
- [ ] ì‹œê°„ ì²˜ë¦¬ê°€ ì˜¬ë°”ë¥¸ê°€?

### 10.2 ì½”ë“œ í’ˆì§ˆ ê²€í† 

**âœ… ê°€ë…ì„±**
- [ ] ë³€ìˆ˜ëª…ê³¼ í•¨ìˆ˜ëª…ì´ ëª…í™•í•œê°€?
- [ ] ì½”ë“œ êµ¬ì¡°ê°€ ì´í•´í•˜ê¸° ì‰¬ìš´ê°€?
- [ ] ì£¼ì„ì´ ì ì ˆíˆ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] ë§¤ì§ ë„˜ë²„ê°€ ìƒìˆ˜ë¡œ ì •ì˜ë˜ì—ˆëŠ”ê°€?

**âœ… ìœ ì§€ë³´ìˆ˜ì„±**
- [ ] í•¨ìˆ˜ê°€ ë‹¨ì¼ ì±…ì„ì„ ê°€ì§€ëŠ”ê°€?
- [ ] ì½”ë“œ ì¤‘ë³µì´ ì œê±°ë˜ì—ˆëŠ”ê°€?
- [ ] ì˜ì¡´ì„±ì´ ì ì ˆíˆ ê´€ë¦¬ë˜ëŠ”ê°€?
- [ ] ì„¤ì •ì´ ì™¸ë¶€í™”ë˜ì—ˆëŠ”ê°€?

### 10.3 ì„±ëŠ¥ ë° ë³´ì•ˆ ê²€í† 

**âœ… ì„±ëŠ¥**
- [ ] ì•Œê³ ë¦¬ì¦˜ ë³µì¡ë„ê°€ ì ì ˆí•œê°€?
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ìµœì í™”ë˜ì—ˆëŠ”ê°€?
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ê°€ íš¨ìœ¨ì ì¸ê°€?
- [ ] ìºì‹±ì´ ì ì ˆíˆ í™œìš©ë˜ëŠ”ê°€?

**âœ… ë³´ì•ˆ**
- [ ] ë¯¼ê°í•œ ì •ë³´ê°€ ì•”í˜¸í™”ë˜ì—ˆëŠ”ê°€?
- [ ] ì…ë ¥ ê²€ì¦ì´ ì¶©ë¶„í•œê°€?
- [ ] SQL ì¸ì ì…˜ ë“± ë³´ì•ˆ ì·¨ì•½ì ì´ ì—†ëŠ”ê°€?
- [ ] ë¡œê·¸ì— ë¯¼ê°í•œ ì •ë³´ê°€ í¬í•¨ë˜ì§€ ì•ŠëŠ”ê°€?

### 10.4 í…ŒìŠ¤íŠ¸ ê²€í† 

**âœ… í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ì¶©ë¶„í•œê°€?
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ê°€ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] ì—£ì§€ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸ê°€ í¬í•¨ë˜ì—ˆëŠ”ê°€?
- [ ] ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•œ ë¶€ë¶„ì— ì‘ì„±ë˜ì—ˆëŠ”ê°€?

---

## ğŸ“‹ 11. ê²°ë¡ 

ì´ í´ë¦° ì½”ë“œ ê°€ì´ë“œë¼ì¸ì€ **ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì˜ í’ˆì§ˆê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ ë³´ì¥**í•˜ê¸° ìœ„í•œ í¬ê´„ì ì¸ ì§€ì¹¨ì…ë‹ˆë‹¤.

### 11.1 í•µì‹¬ ì›ì¹™ ìš”ì•½

1. **ê°€ë…ì„± ìš°ì„ **: ì½”ë“œëŠ” ì‚¬ëŒì´ ì½ê¸° ìœ„í•´ ì‘ì„±
2. **ë‹¨ì¼ ì±…ì„**: ê° ëª¨ë“ˆê³¼ í•¨ìˆ˜ëŠ” í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì§
3. **ì˜ì¡´ì„± ì£¼ì…**: ìœ ì—°í•˜ê³  í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ì„¤ê³„
4. **ì˜¤ë¥˜ ì²˜ë¦¬**: ì˜ˆìƒ ê°€ëŠ¥í•œ ëª¨ë“  ì˜¤ë¥˜ ìƒí™© ëŒ€ì‘
5. **ì„±ëŠ¥ ìµœì í™”**: ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” ìµœì ì˜ ì„±ëŠ¥
6. **ë³´ì•ˆ ê°•í™”**: ë¯¼ê°í•œ ì •ë³´ì™€ ì‹œìŠ¤í…œ ë³´í˜¸
7. **í…ŒìŠ¤íŠ¸ ìš°ì„ **: ëª¨ë“  ì½”ë“œëŠ” í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•˜ê²Œ ì„¤ê³„
8. **ë¬¸ì„œí™”**: ì½”ë“œì™€ í•¨ê»˜ ì—…ë°ì´íŠ¸ë˜ëŠ” ì‚´ì•„ìˆëŠ” ë¬¸ì„œ

### 11.2 ì§€ì†ì  ê°œì„ 

- **ì½”ë“œ ë¦¬ë·°**: ëª¨ë“  ì½”ë“œ ë³€ê²½ì‚¬í•­ì— ëŒ€í•œ ë™ë£Œ ê²€í† 
- **ì •ì  ë¶„ì„**: SonarQube, Pylint ë“± ë„êµ¬ í™œìš©
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ì§€ì†ì ì¸ ì„±ëŠ¥ ì¸¡ì • ë° ìµœì í™”
- **ë³´ì•ˆ ìŠ¤ìº”**: ì •ê¸°ì ì¸ ë³´ì•ˆ ì·¨ì•½ì  ê²€ì‚¬
- **ë¦¬íŒ©í† ë§**: ê¸°ëŠ¥ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ê°œì„ 

ì´ ê°€ì´ë“œë¼ì¸ì„ ë”°ë¼ **ì„¸ê³„ ìµœê³  ìˆ˜ì¤€ì˜ ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ**ì„ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

---

**ë¬¸ì„œ ë**

