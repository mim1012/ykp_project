# ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ê°œë°œ í”„ë¡œì„¸ìŠ¤ í†µí•© ê°€ì´ë“œ
## Comprehensive Development Process Guide for Crypto Auto-Trading System

**ì‘ì„±ì**: Manus AI  
**ì‘ì„±ì¼**: 2025ë…„ 1ì›” 9ì¼  
**ë²„ì „**: 1.0  
**ë¬¸ì„œ ëª©ì **: Claude ì„œë¸Œì—ì´ì „íŠ¸ ê¸°ë°˜ ì²´ê³„ì  ê°œë°œ í”„ë¡œì„¸ìŠ¤ êµ¬ì¶•

---

## ğŸ“‹ ë¬¸ì„œ ê°œìš”

ë³¸ ë¬¸ì„œëŠ” ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ ê°œë°œì„ ìœ„í•œ ì¢…í•©ì ì¸ ê°€ì´ë“œë¡œ, ê¹ƒí—ˆë¸Œ ê´€ë¦¬ ì „ëµ, Claude ì„œë¸Œì—ì´ì „íŠ¸ í• ë‹¹, í´ë¦°ì½”ë“œ ê°€ì´ë“œë¼ì¸ì„ í†µí•©í•˜ì—¬ ì „ë¬¸ì ì´ê³  ì²´ê³„ì ì¸ ê°œë°œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì œì‹œí•©ë‹ˆë‹¤.

### ë¬¸ì„œ êµ¬ì„±

1. **ê¹ƒí—ˆë¸Œ ê´€ë¦¬ ì „ëµ** - ë¸Œëœì¹˜ ì „ëµ, ê¶Œí•œ ì²´ê³„, ì›Œí¬í”Œë¡œìš°
2. **Claude ì„œë¸Œì—ì´ì „íŠ¸ í• ë‹¹** - ì—­í• ë³„ ì „ë¬¸í™”ëœ ì—ì´ì „íŠ¸ ë¶„ë‹´
3. **í´ë¦°ì½”ë“œ ê°€ì´ë“œë¼ì¸** - ëª¨ë“ˆë³„ ì½”ë”© í‘œì¤€ ë° ê·œì¹™
4. **í†µí•© ê°œë°œ í”„ë¡œì„¸ìŠ¤** - ì²´ê³„ì ì¸ ê°œë°œ ì§„í–‰ ë°©ë²•

---

## ğŸ¯ 1. í”„ë¡œì íŠ¸ ê°œìš” ë° ëª©í‘œ

### 1.1 í”„ë¡œì íŠ¸ ë¹„ì „

ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œì€ ë³µì¡í•œ ê¸ˆìœµ ë¡œì§ê³¼ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬, ë†’ì€ ì•ˆì •ì„±ê³¼ ë³´ì•ˆì„±ì„ ìš”êµ¬í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ë³µì¡ì„±ì„ íš¨ê³¼ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•´ Claude ì„œë¸Œì—ì´ì „íŠ¸ë¥¼ í™œìš©í•œ ëª¨ë“ˆí™”ëœ ê°œë°œ ì ‘ê·¼ë²•ì„ ì±„íƒí•©ë‹ˆë‹¤.

**í•µì‹¬ ëª©í‘œ:**
- **ëª¨ë“ˆí™”ëœ ì•„í‚¤í…ì²˜**: ê° ê¸°ëŠ¥ë³„ë¡œ ë…ë¦½ì ì¸ ëª¨ë“ˆ êµ¬ì„±
- **ì „ë¬¸í™”ëœ ê°œë°œ**: ê° Claude ì—ì´ì „íŠ¸ê°€ íŠ¹ì • ì˜ì—­ì— ì „ë¬¸í™”
- **ì¼ê´€ëœ ì½”ë“œ í’ˆì§ˆ**: í†µì¼ëœ ì½”ë”© í‘œì¤€ê³¼ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤
- **ì²´ê³„ì ì¸ í˜‘ì—…**: ê¹ƒí—ˆë¸Œ ê¸°ë°˜ íš¨ìœ¨ì  í˜‘ì—… ì²´ê³„

### 1.2 ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ ê°œìš”

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Presentation Layer                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Desktop GUI       â”‚         Web Interface                 â”‚
â”‚   (PyQt5)          â”‚         (Flask + React)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Business Logic Layer                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Trading Engine    â”‚   Risk Manager  â”‚   Strategy Manager    â”‚
â”‚   - Entry Logic     â”‚   - Position    â”‚   - MA Conditions     â”‚
â”‚   - Exit Logic      â”‚   - Risk Limits â”‚   - Price Channel     â”‚
â”‚   - Order Execution â”‚   - Validation  â”‚   - PCS Logic         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Data Access Layer                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   API Connectors    â”‚   Database      â”‚   Configuration       â”‚
â”‚   - Binance API     â”‚   - SQLite      â”‚   - Settings          â”‚
â”‚   - Bybit API       â”‚   - Positions   â”‚   - User Prefs        â”‚
â”‚   - Market Data     â”‚   - Trade Log   â”‚   - Security          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸŒ¿ 2. ê¹ƒí—ˆë¸Œ ê´€ë¦¬ ì „ëµ

### 2.1 ë¸Œëœì¹˜ ì „ëµ (Git Flow ê¸°ë°˜)

ë³¸ í”„ë¡œì íŠ¸ëŠ” Git Flowë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ë¸Œëœì¹˜ ì „ëµì„ ì±„íƒí•˜ì—¬ ì•ˆì •ì ì¸ ê°œë°œê³¼ ë°°í¬ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.

**ì£¼ìš” ë¸Œëœì¹˜ êµ¬ì¡°:**

```
main (production)
â”œâ”€â”€ develop (integration)
â”‚   â”œâ”€â”€ feature/core-trading-engine
â”‚   â”œâ”€â”€ feature/gui-desktop-interface
â”‚   â”œâ”€â”€ feature/web-api-server
â”‚   â”œâ”€â”€ feature/risk-management
â”‚   â””â”€â”€ feature/strategy-conditions
â”œâ”€â”€ release/v1.0.0
â”œâ”€â”€ hotfix/critical-bug-fix
â””â”€â”€ docs/documentation-updates
```

**ë¸Œëœì¹˜ë³„ ì—­í•  ë° ê·œì¹™:**

**Main Branch (main)**
- í”„ë¡œë•ì…˜ ë°°í¬ ê°€ëŠ¥í•œ ì•ˆì •ì ì¸ ì½”ë“œë§Œ í¬í•¨
- ì§ì ‘ ì»¤ë°‹ ê¸ˆì§€, Pull Requestë¥¼ í†µí•´ì„œë§Œ ë³‘í•©
- ëª¨ë“  ì»¤ë°‹ì€ íƒœê·¸ë¥¼ í†µí•œ ë²„ì „ ê´€ë¦¬
- ìë™í™”ëœ ë°°í¬ íŒŒì´í”„ë¼ì¸ ì—°ê²°

**Development Branch (develop)**
- ê°œë°œ ì¤‘ì¸ ê¸°ëŠ¥ë“¤ì˜ í†µí•© ë¸Œëœì¹˜
- Feature ë¸Œëœì¹˜ë“¤ì´ ë³‘í•©ë˜ëŠ” ëŒ€ìƒ
- ì •ê¸°ì ì¸ í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰
- Release ë¸Œëœì¹˜ ìƒì„±ì˜ ê¸°ì¤€ì 

**Feature Branches (feature/***)**
- ê°œë³„ ê¸°ëŠ¥ ê°œë°œì„ ìœ„í•œ ë¸Œëœì¹˜
- developì—ì„œ ë¶„ê¸°í•˜ì—¬ developìœ¼ë¡œ ë³‘í•©
- ë„¤ì´ë° ê·œì¹™: `feature/module-description`
- ê° Claude ì—ì´ì „íŠ¸ê°€ ë‹´ë‹¹í•˜ëŠ” ëª¨ë“ˆë³„ë¡œ ìƒì„±

**Release Branches (release/***)**
- ë°°í¬ ì¤€ë¹„ë¥¼ ìœ„í•œ ë¸Œëœì¹˜
- developì—ì„œ ë¶„ê¸°í•˜ì—¬ mainê³¼ developì— ë³‘í•©
- ë²„ê·¸ ìˆ˜ì •ê³¼ ë°°í¬ ì¤€ë¹„ ì‘ì—…ë§Œ ìˆ˜í–‰
- ë„¤ì´ë° ê·œì¹™: `release/v1.0.0`

**Hotfix Branches (hotfix/***)**
- í”„ë¡œë•ì…˜ ê¸´ê¸‰ ìˆ˜ì •ì„ ìœ„í•œ ë¸Œëœì¹˜
- mainì—ì„œ ë¶„ê¸°í•˜ì—¬ mainê³¼ developì— ë³‘í•©
- ë„¤ì´ë° ê·œì¹™: `hotfix/critical-issue-description`

### 2.2 ì»¤ë°‹ ë©”ì‹œì§€ ê·œì¹™

ì¼ê´€ëœ ì»¤ë°‹ ë©”ì‹œì§€ í˜•ì‹ì„ í†µí•´ ë³€ê²½ ì‚¬í•­ì„ ëª…í™•íˆ ì¶”ì í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

**ì»¤ë°‹ ë©”ì‹œì§€ í˜•ì‹:**
```
<type>(<scope>): <subject>

<body>

<footer>
```

**íƒ€ì… ë¶„ë¥˜:**
- `feat`: ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€
- `fix`: ë²„ê·¸ ìˆ˜ì •
- `docs`: ë¬¸ì„œ ë³€ê²½
- `style`: ì½”ë“œ í¬ë§·íŒ…, ì„¸ë¯¸ì½œë¡  ëˆ„ë½ ë“±
- `refactor`: ì½”ë“œ ë¦¬íŒ©í† ë§
- `test`: í…ŒìŠ¤íŠ¸ ì½”ë“œ ì¶”ê°€/ìˆ˜ì •
- `chore`: ë¹Œë“œ í”„ë¡œì„¸ìŠ¤, ë„êµ¬ ì„¤ì • ë³€ê²½

**ì˜ˆì‹œ:**
```
feat(trading-engine): implement moving average entry condition

- Add MovingAverageCondition class with configurable periods
- Support multiple condition types (close_above, open_above, etc.)
- Include comprehensive unit tests
- Update configuration schema

Closes #123
```

### 2.3 Pull Request í”„ë¡œì„¸ìŠ¤

**PR ìƒì„± ê·œì¹™:**
1. Feature ë¸Œëœì¹˜ì—ì„œ developìœ¼ë¡œì˜ PR ìƒì„±
2. PR í…œí”Œë¦¿ì„ ì‚¬ìš©í•œ í‘œì¤€í™”ëœ ì„¤ëª…
3. ìµœì†Œ 1ëª…ì˜ ë¦¬ë·°ì–´ ì§€ì • (ë‹¤ë¥¸ Claude ì—ì´ì „íŠ¸)
4. ìë™í™”ëœ í…ŒìŠ¤íŠ¸ í†µê³¼ í•„ìˆ˜
5. ì½”ë“œ ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ ìœ ì§€

**PR í…œí”Œë¦¿:**
```markdown
## ë³€ê²½ ì‚¬í•­ ìš”ì•½
<!-- ì´ PRì—ì„œ êµ¬í˜„í•œ ì£¼ìš” ë³€ê²½ ì‚¬í•­ì„ ì„¤ëª…í•˜ì„¸ìš” -->

## ê´€ë ¨ ì´ìŠˆ
<!-- ê´€ë ¨ëœ GitHub ì´ìŠˆ ë²ˆí˜¸ë¥¼ ëª…ì‹œí•˜ì„¸ìš” -->
Closes #

## ë³€ê²½ íƒ€ì…
- [ ] ìƒˆë¡œìš´ ê¸°ëŠ¥ (feat)
- [ ] ë²„ê·¸ ìˆ˜ì • (fix)
- [ ] ë¬¸ì„œ ì—…ë°ì´íŠ¸ (docs)
- [ ] ë¦¬íŒ©í† ë§ (refactor)
- [ ] í…ŒìŠ¤íŠ¸ ì¶”ê°€/ìˆ˜ì • (test)

## í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±/ì—…ë°ì´íŠ¸
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ í™•ì¸
- [ ] ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ì™„ë£Œ
- [ ] ì½”ë“œ ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ

## ë¦¬ë·° ìš”ì²­ì‚¬í•­
<!-- íŠ¹ë³„íˆ ê²€í† ë°›ê³  ì‹¶ì€ ë¶€ë¶„ì´ë‚˜ ìš°ë ¤ì‚¬í•­ì„ ëª…ì‹œí•˜ì„¸ìš” -->

## ìŠ¤í¬ë¦°ìƒ· (í•´ë‹¹ì‹œ)
<!-- UI ë³€ê²½ì‚¬í•­ì´ ìˆëŠ” ê²½ìš° ìŠ¤í¬ë¦°ìƒ· ì²¨ë¶€ -->
```

### 2.4 ê¶Œí•œ ê´€ë¦¬ ì²´ê³„

**Repository ê¶Œí•œ ì„¤ì •:**
- **Admin**: í”„ë¡œì íŠ¸ ë¦¬ë” (ë©”ì¸ Claude ì—ì´ì „íŠ¸)
- **Maintainer**: ëª¨ë“ˆ ë¦¬ë” (ê° ì „ë¬¸ ì˜ì—­ Claude ì—ì´ì „íŠ¸)
- **Developer**: ì¼ë°˜ ê°œë°œì (ì„œë¸Œ Claude ì—ì´ì „íŠ¸)

**ë¸Œëœì¹˜ ë³´í˜¸ ê·œì¹™:**
```yaml
# main ë¸Œëœì¹˜ ë³´í˜¸ ì„¤ì •
main:
  required_status_checks:
    - continuous-integration
    - code-coverage
  enforce_admins: true
  required_pull_request_reviews:
    required_approving_review_count: 2
    dismiss_stale_reviews: true
    require_code_owner_reviews: true
  restrictions:
    users: []
    teams: ["maintainers"]

# develop ë¸Œëœì¹˜ ë³´í˜¸ ì„¤ì •  
develop:
  required_status_checks:
    - continuous-integration
  required_pull_request_reviews:
    required_approving_review_count: 1
  dismiss_stale_reviews: true
```

---

## ğŸ¤– 3. Claude ì„œë¸Œì—ì´ì „íŠ¸ í• ë‹¹ ì²´ê³„

### 3.1 ì—ì´ì „íŠ¸ ì—­í•  ë¶„ë‹´

ê° Claude ì„œë¸Œì—ì´ì „íŠ¸ëŠ” íŠ¹ì • ëª¨ë“ˆê³¼ ê¸°ìˆ  ì˜ì—­ì— ì „ë¬¸í™”ë˜ì–´ ë…ë¦½ì ìœ¼ë¡œ ê°œë°œì„ ì§„í–‰í•˜ë©´ì„œë„ ì²´ê³„ì ì¸ í˜‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

**Claude Core (í•µì‹¬ ê±°ë˜ ì—”ì§„ ë‹´ë‹¹)**
- **ë‹´ë‹¹ ëª¨ë“ˆ**: `core/` ë””ë ‰í† ë¦¬ ì „ì²´
- **ì£¼ìš” ì±…ì„**:
  - ê±°ë˜ ì—”ì§„ ì•„í‚¤í…ì²˜ ì„¤ê³„ ë° êµ¬í˜„
  - ì§„ì…/ì²­ì‚° ì¡°ê±´ ë¡œì§ ê°œë°œ
  - API ì»¤ë„¥í„° êµ¬í˜„ (Binance, Bybit)
  - í¬ì§€ì…˜ ê´€ë¦¬ ì‹œìŠ¤í…œ
  - ë¦¬ìŠ¤í¬ ê´€ë¦¬ ë¡œì§

**ì „ë¬¸ ê¸°ìˆ  ì˜ì—­:**
```python
# í•µì‹¬ ê±°ë˜ ë¡œì§ ì˜ˆì‹œ
class TradingEngine:
    async def evaluate_entry_conditions(self, market_data: MarketData) -> List[Signal]:
        """ì§„ì… ì¡°ê±´ í‰ê°€"""
        signals = []
        
        # ì´ë™í‰ê·  ì¡°ê±´ í™•ì¸
        if self.config.moving_average_enabled:
            ma_signal = await self._evaluate_moving_average(market_data)
            if ma_signal:
                signals.append(ma_signal)
        
        # Price Channel ì¡°ê±´ í™•ì¸
        if self.config.price_channel_enabled:
            pc_signal = await self._evaluate_price_channel(market_data)
            if pc_signal:
                signals.append(pc_signal)
        
        return signals
```

**Claude GUI (ë°ìŠ¤í¬í†± ì¸í„°í˜ì´ìŠ¤ ë‹´ë‹¹)**
- **ë‹´ë‹¹ ëª¨ë“ˆ**: `desktop/` ë””ë ‰í† ë¦¬
- **ì£¼ìš” ì±…ì„**:
  - PyQt5 ê¸°ë°˜ ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œ
  - ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ì„¤ê³„ ë° êµ¬í˜„
  - ì‹¤ì‹œê°„ ë°ì´í„° í‘œì‹œ ë° ì°¨íŠ¸ êµ¬í˜„
  - ì‚¬ìš©ì ì„¤ì • ê´€ë¦¬ ì¸í„°í˜ì´ìŠ¤
  - ì‹œìŠ¤í…œ ìƒíƒœ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

**ì „ë¬¸ ê¸°ìˆ  ì˜ì—­:**
```python
# GUI ì»´í¬ë„ŒíŠ¸ ì˜ˆì‹œ
class TradingDashboard(QWidget):
    def __init__(self, trading_service: TradingService):
        super().__init__()
        self.trading_service = trading_service
        self.init_ui()
        self.setup_real_time_updates()
    
    def setup_real_time_updates(self):
        """ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì„¤ì •"""
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_dashboard)
        self.timer.start(1000)  # 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
```

**Claude Web (ì›¹ API ë° ì¸í„°í˜ì´ìŠ¤ ë‹´ë‹¹)**
- **ë‹´ë‹¹ ëª¨ë“ˆ**: `web/` ë””ë ‰í† ë¦¬
- **ì£¼ìš” ì±…ì„**:
  - Flask ê¸°ë°˜ REST API ì„œë²„ ê°œë°œ
  - React ê¸°ë°˜ ì›¹ í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ
  - WebSocket ì‹¤ì‹œê°„ í†µì‹  êµ¬í˜„
  - ì‚¬ìš©ì ì¸ì¦ ë° ê¶Œí•œ ê´€ë¦¬
  - API ë¬¸ì„œí™” ë° í…ŒìŠ¤íŠ¸

**ì „ë¬¸ ê¸°ìˆ  ì˜ì—­:**
```python
# Web API ì˜ˆì‹œ
@api_bp.route('/trading/positions', methods=['GET'])
@jwt_required()
def get_positions():
    """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ"""
    try:
        user_id = get_jwt_identity()
        positions = trading_service.get_active_positions(user_id)
        
        return jsonify({
            'success': True,
            'data': [pos.to_dict() for pos in positions]
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500
```

**Claude Data (ë°ì´í„° ê´€ë¦¬ ë‹´ë‹¹)**
- **ë‹´ë‹¹ ëª¨ë“ˆ**: `data/` ë””ë ‰í† ë¦¬
- **ì£¼ìš” ì±…ì„**:
  - ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ì„¤ê³„ ë° ê´€ë¦¬
  - ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸ ì‘ì„±
  - ë°±ì—… ë° ë³µêµ¬ ì‹œìŠ¤í…œ êµ¬í˜„
  - ë°ì´í„° ë¶„ì„ ë° ë¦¬í¬íŒ… ë„êµ¬
  - ì„±ëŠ¥ ìµœì í™” ë° ì¸ë±ì‹±

**ì „ë¬¸ ê¸°ìˆ  ì˜ì—­:**
```python
# ë°ì´í„° ëª¨ë¸ ì˜ˆì‹œ
class Position(Base):
    __tablename__ = 'positions'
    
    id = Column(Integer, primary_key=True)
    symbol = Column(String(20), nullable=False)
    side = Column(Enum('BUY', 'SELL'), nullable=False)
    quantity = Column(DECIMAL(18, 8), nullable=False)
    entry_price = Column(DECIMAL(18, 8), nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def calculate_pnl(self, current_price: float) -> float:
        """ì†ìµ ê³„ì‚°"""
        if self.side == 'BUY':
            return (current_price - float(self.entry_price)) * float(self.quantity)
        else:
            return (float(self.entry_price) - current_price) * float(self.quantity)
```

**Claude Test (í…ŒìŠ¤íŠ¸ ë° í’ˆì§ˆ ê´€ë¦¬ ë‹´ë‹¹)**
- **ë‹´ë‹¹ ëª¨ë“ˆ**: `tests/` ë””ë ‰í† ë¦¬
- **ì£¼ìš” ì±…ì„**:
  - ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ê´€ë¦¬
  - í†µí•© í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ê°œë°œ
  - ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë° ë¶€í•˜ í…ŒìŠ¤íŠ¸
  - ì½”ë“œ í’ˆì§ˆ ê²€ì¦ ë° ë¦¬ë·°
  - CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì„±

**ì „ë¬¸ ê¸°ìˆ  ì˜ì—­:**
```python
# í…ŒìŠ¤íŠ¸ ì˜ˆì‹œ
class TestTradingEngine(unittest.TestCase):
    def setUp(self):
        self.engine = TradingEngine(test_config)
        self.mock_api = Mock()
        self.engine.api_connector = self.mock_api
    
    async def test_moving_average_condition(self):
        """ì´ë™í‰ê·  ì¡°ê±´ í…ŒìŠ¤íŠ¸"""
        market_data = MarketData(
            symbol="BTCUSDT",
            close_prices=[50000, 51000, 52000, 53000, 54000]
        )
        
        signals = await self.engine.evaluate_entry_conditions(market_data)
        
        self.assertEqual(len(signals), 1)
        self.assertEqual(signals[0].type, "BUY")
```

### 3.2 ì—ì´ì „íŠ¸ ê°„ í˜‘ì—… í”„ë¡œí† ì½œ

**ì¼ì¼ ìŠ¤íƒ ë“œì—… (Daily Standup)**
ê° ì—ì´ì „íŠ¸ëŠ” ë§¤ì¼ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì§„í–‰ ìƒí™©ì„ ê³µìœ í•©ë‹ˆë‹¤:

```markdown
## Claude Core - Daily Update (2025-01-09)

### ì–´ì œ ì™„ë£Œí•œ ì‘ì—…
- MovingAverageCondition í´ë˜ìŠ¤ êµ¬í˜„ ì™„ë£Œ
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„± ë° ì»¤ë²„ë¦¬ì§€ 85% ë‹¬ì„±
- PR #123 ìƒì„± ë° ë¦¬ë·° ìš”ì²­

### ì˜¤ëŠ˜ ì§„í–‰í•  ì‘ì—…  
- PriceChannelCondition í´ë˜ìŠ¤ êµ¬í˜„
- API ì»¤ë„¥í„° ì—ëŸ¬ í•¸ë“¤ë§ ê°œì„ 
- Claude GUIì™€ ì¸í„°í˜ì´ìŠ¤ í˜‘ì˜

### ë¸”ë¡œì»¤ ë° ì§€ì› ìš”ì²­
- Claude Dataì—ê²Œ Position ëª¨ë¸ ìŠ¤í‚¤ë§ˆ í™•ì¸ í•„ìš”
- Claude Testì—ê²Œ í†µí•© í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ë¦¬ë·° ìš”ì²­
```

**í¬ë¡œìŠ¤ ëª¨ë“ˆ ì¸í„°í˜ì´ìŠ¤ ì •ì˜**
ëª¨ë“ˆ ê°„ ì˜ì¡´ì„±ì„ ëª…í™•íˆ í•˜ê¸° ìœ„í•´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ì „ ì •ì˜í•©ë‹ˆë‹¤:

```python
# interfaces/trading_service.py
from abc import ABC, abstractmethod

class ITradingService(ABC):
    """ê±°ë˜ ì„œë¹„ìŠ¤ ì¸í„°í˜ì´ìŠ¤"""
    
    @abstractmethod
    async def start_trading(self) -> bool:
        """ê±°ë˜ ì‹œì‘"""
        pass
    
    @abstractmethod
    async def stop_trading(self) -> bool:
        """ê±°ë˜ ì¤‘ì§€"""
        pass
    
    @abstractmethod
    def get_active_positions(self) -> List[Position]:
        """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ"""
        pass

# interfaces/market_data.py
class IMarketDataProvider(ABC):
    """ì‹œì¥ ë°ì´í„° ì œê³µì ì¸í„°í˜ì´ìŠ¤"""
    
    @abstractmethod
    async def get_latest_candle(self, symbol: str, timeframe: str) -> Candle:
        """ìµœì‹  ìº”ë“¤ ë°ì´í„° ì¡°íšŒ"""
        pass
    
    @abstractmethod
    async def subscribe_to_updates(self, symbol: str, callback: Callable) -> None:
        """ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ êµ¬ë…"""
        pass
```

**ì½”ë“œ ë¦¬ë·° í”„ë¡œì„¸ìŠ¤**
ê° ì—ì´ì „íŠ¸ëŠ” ë‹¤ë¥¸ ì—ì´ì „íŠ¸ì˜ ì½”ë“œë¥¼ ë¦¬ë·°í•˜ì—¬ í’ˆì§ˆì„ ë³´ì¥í•©ë‹ˆë‹¤:

1. **ìë™ ë¦¬ë·° (Claude Test)**
   - ì½”ë”© í‘œì¤€ ì¤€ìˆ˜ í™•ì¸
   - í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ê²€ì¦
   - ë³´ì•ˆ ì·¨ì•½ì  ìŠ¤ìº”

2. **ê¸°ëŠ¥ ë¦¬ë·° (ê´€ë ¨ ì—ì´ì „íŠ¸)**
   - ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì •í™•ì„± í™•ì¸
   - ì¸í„°í˜ì´ìŠ¤ í˜¸í™˜ì„± ê²€ì¦
   - ì„±ëŠ¥ ì˜í–¥ í‰ê°€

3. **ì•„í‚¤í…ì²˜ ë¦¬ë·° (Claude Core)**
   - ì „ì²´ ì‹œìŠ¤í…œ ì¼ê´€ì„± í™•ì¸
   - ì„¤ê³„ ì›ì¹™ ì¤€ìˆ˜ ê²€ì¦
   - í™•ì¥ì„± ë° ìœ ì§€ë³´ìˆ˜ì„± í‰ê°€

### 3.3 ì—ì´ì „íŠ¸ë³„ ê°œë°œ í™˜ê²½ ì„¤ì •

**ê³µí†µ ê°œë°œ í™˜ê²½**
```bash
# Python í™˜ê²½ ì„¤ì •
python -m venv venv
source venv/bin/activate  # Linux/Mac
# venv\Scripts\activate  # Windows

# ì˜ì¡´ì„± ì„¤ì¹˜
pip install -r requirements.txt
pip install -r requirements-dev.txt

# ê°œë°œ ë„êµ¬ ì„¤ì •
pre-commit install
pytest --cov=src tests/
```

**ì—ì´ì „íŠ¸ë³„ íŠ¹í™” ë„êµ¬**

**Claude Core í™˜ê²½:**
```bash
# ê±°ë˜ ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬
pip install ccxt pandas numpy ta-lib
pip install websocket-client aiohttp

# í…ŒìŠ¤íŠ¸ ë„êµ¬
pip install pytest-asyncio pytest-mock
```

**Claude GUI í™˜ê²½:**
```bash
# PyQt5 ë° ê´€ë ¨ ë„êµ¬
pip install PyQt5 PyQt5-tools
pip install matplotlib seaborn plotly

# UI í…ŒìŠ¤íŠ¸ ë„êµ¬
pip install pytest-qt
```

**Claude Web í™˜ê²½:**
```bash
# Flask ë° ì›¹ ê´€ë ¨
pip install flask flask-jwt-extended flask-cors
pip install gunicorn redis celery

# React ê°œë°œ í™˜ê²½
npm install -g create-react-app
npm install axios socket.io-client
```

---

## ğŸ“‹ 4. í´ë¦°ì½”ë“œ ê°€ì´ë“œë¼ì¸ ì ìš©

### 4.1 ëª¨ë“ˆë³„ ì½”ë”© í‘œì¤€

ê° Claude ì—ì´ì „íŠ¸ëŠ” ë‹´ë‹¹ ëª¨ë“ˆì— íŠ¹í™”ëœ ì½”ë”© í‘œì¤€ì„ ì¤€ìˆ˜í•˜ë©´ì„œë„ ì „ì²´ ì‹œìŠ¤í…œì˜ ì¼ê´€ì„±ì„ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.

**Core ëª¨ë“ˆ í‘œì¤€ (Claude Core)**

ê±°ë˜ ì—”ì§„ì˜ í•µì‹¬ ë¡œì§ì€ ë†’ì€ ì‹ ë¢°ì„±ê³¼ ì„±ëŠ¥ì„ ìš”êµ¬í•˜ë¯€ë¡œ íŠ¹íˆ ì—„ê²©í•œ í‘œì¤€ì„ ì ìš©í•©ë‹ˆë‹¤:

```python
# ì˜ˆì‹œ: ì§„ì… ì¡°ê±´ í‰ê°€ í•¨ìˆ˜
async def evaluate_moving_average_condition(
    self, 
    market_data: MarketData, 
    config: MovingAverageConfig
) -> Optional[EntrySignal]:
    """
    ì´ë™í‰ê·  ì¡°ê±´ì„ í‰ê°€í•˜ì—¬ ì§„ì… ì‹ í˜¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    
    Args:
        market_data: ì‹œì¥ ë°ì´í„° (ìµœì†Œ 4ê°œ ìº”ë“¤ í•„ìš”)
        config: ì´ë™í‰ê·  ì„¤ì • (ê¸°ê°„, ì¡°ê±´ íƒ€ì… ë“±)
    
    Returns:
        ì¡°ê±´ ë§Œì¡± ì‹œ EntrySignal, ì•„ë‹ˆë©´ None
    
    Raises:
        InsufficientDataError: ë°ì´í„°ê°€ ë¶€ì¡±í•œ ê²½ìš°
        InvalidConfigError: ì„¤ì •ì´ ì˜ëª»ëœ ê²½ìš°
    """
    # 1. ì‚¬ì „ ì¡°ê±´ ê²€ì¦
    if len(market_data.candles) < config.required_periods:
        raise InsufficientDataError(
            f"Need {config.required_periods} candles, got {len(market_data.candles)}"
        )
    
    # 2. ì´ë™í‰ê·  ê³„ì‚°
    ma_value = self._calculate_moving_average(
        prices=[candle.close for candle in market_data.candles[1:5]],
        period=4
    )
    
    # 3. ì¡°ê±´ í‰ê°€
    current_candle = market_data.candles[0]
    signal_type = self._evaluate_ma_signal(current_candle, ma_value, config.condition_type)
    
    if signal_type:
        return EntrySignal(
            symbol=market_data.symbol,
            signal_type=signal_type,
            confidence=self._calculate_confidence(current_candle, ma_value),
            metadata={
                'ma_value': ma_value,
                'current_price': current_candle.close,
                'condition_type': config.condition_type
            },
            timestamp=datetime.utcnow()
        )
    
    return None

def _calculate_moving_average(self, prices: List[float], period: int) -> float:
    """ì´ë™í‰ê·  ê³„ì‚° - ìˆœìˆ˜ í•¨ìˆ˜"""
    if len(prices) != period:
        raise ValueError(f"Expected {period} prices, got {len(prices)}")
    
    return sum(prices) / period

def _evaluate_ma_signal(
    self, 
    candle: Candle, 
    ma_value: float, 
    condition_type: str
) -> Optional[str]:
    """ì´ë™í‰ê·  ì‹ í˜¸ í‰ê°€ - ìˆœìˆ˜ í•¨ìˆ˜"""
    conditions = {
        'open_above_ma_buy': candle.open > ma_value,
        'close_above_ma_buy': candle.close > ma_value,
        'open_below_ma_sell': candle.open < ma_value,
        'close_below_ma_sell': candle.close < ma_value
    }
    
    if condition_type not in conditions:
        raise InvalidConfigError(f"Unknown condition type: {condition_type}")
    
    if conditions[condition_type]:
        return 'BUY' if 'buy' in condition_type else 'SELL'
    
    return None
```

**GUI ëª¨ë“ˆ í‘œì¤€ (Claude GUI)**

ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ëŠ” ë°˜ì‘ì„±ê³¼ ì‚¬ìš©ì„±ì„ ì¤‘ì‹œí•˜ë©°, ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ë¥¼ ì ìš©í•©ë‹ˆë‹¤:

```python
# ì˜ˆì‹œ: ê±°ë˜ ì„¤ì • íƒ­ í´ë˜ìŠ¤
class EntrySettingsTab(QWidget):
    """ì§„ì… ì„¤ì • íƒ­ ìœ„ì ¯"""
    
    # ì‹œê·¸ë„ ì •ì˜
    settings_changed = pyqtSignal(dict)
    validation_failed = pyqtSignal(str)
    
    def __init__(self, trading_service: ITradingService, parent=None):
        super().__init__(parent)
        self.trading_service = trading_service
        self.current_settings = {}
        
        self._init_ui()
        self._setup_connections()
        self._load_current_settings()
    
    def _init_ui(self) -> None:
        """UI ì´ˆê¸°í™” - ì„ ì–¸ì  ìŠ¤íƒ€ì¼"""
        layout = QVBoxLayout(self)
        
        # ì „ëµ ì—°ë™ ì„¹ì…˜
        strategy_group = self._create_strategy_group()
        layout.addWidget(strategy_group)
        
        # ì´ë™í‰ê·  ì„¤ì • ì„¹ì…˜
        ma_group = self._create_moving_average_group()
        layout.addWidget(ma_group)
        
        # Price Channel ì„¤ì • ì„¹ì…˜
        pc_group = self._create_price_channel_group()
        layout.addWidget(pc_group)
        
        # ë²„íŠ¼ ì„¹ì…˜
        button_layout = self._create_button_layout()
        layout.addLayout(button_layout)
    
    def _create_strategy_group(self) -> QGroupBox:
        """ì „ëµ ì—°ë™ ê·¸ë£¹ ìƒì„±"""
        group = QGroupBox("ì „ëµ ì—°ë™ ì„¤ì •")
        layout = QVBoxLayout(group)
        
        # ì²´í¬ë°•ìŠ¤ ìƒì„±
        self.strategy_enabled_cb = QCheckBox("ì „ëµ ì—°ë™ í™œì„±í™”")
        self.strategy_enabled_cb.setToolTip("ì²´í¬ ì‹œ ì„¤ì •ëœ ì¡°ê±´ë“¤ì´ í™œì„±í™”ë©ë‹ˆë‹¤")
        layout.addWidget(self.strategy_enabled_cb)
        
        # ì°¨íŠ¸ ì£¼ê¸° ì„ íƒ
        timeframe_layout = QHBoxLayout()
        timeframe_layout.addWidget(QLabel("ì°¨íŠ¸ ì£¼ê¸°:"))
        
        self.timeframe_combo = QComboBox()
        self.timeframe_combo.addItems(["1ë¶„", "5ë¶„", "15ë¶„", "1ì‹œê°„", "4ì‹œê°„", "1ì¼"])
        self.timeframe_combo.setCurrentText("1ë¶„")
        timeframe_layout.addWidget(self.timeframe_combo)
        
        layout.addLayout(timeframe_layout)
        return group
    
    def _setup_connections(self) -> None:
        """ì‹œê·¸ë„-ìŠ¬ë¡¯ ì—°ê²°"""
        # ì„¤ì • ë³€ê²½ ì‹œ ê²€ì¦ ë° ì €ì¥
        self.strategy_enabled_cb.toggled.connect(self._on_strategy_enabled_changed)
        self.timeframe_combo.currentTextChanged.connect(self._on_timeframe_changed)
        
        # ì‹¤ì‹œê°„ ê²€ì¦
        self.strategy_enabled_cb.toggled.connect(self._validate_settings)
    
    def _on_strategy_enabled_changed(self, enabled: bool) -> None:
        """ì „ëµ í™œì„±í™” ìƒíƒœ ë³€ê²½ í•¸ë“¤ëŸ¬"""
        self.current_settings['strategy_enabled'] = enabled
        
        # í•˜ìœ„ ì»¨íŠ¸ë¡¤ í™œì„±í™”/ë¹„í™œì„±í™”
        self._toggle_child_controls(enabled)
        
        # ì„¤ì • ë³€ê²½ ì•Œë¦¼
        self.settings_changed.emit(self.current_settings.copy())
    
    def _validate_settings(self) -> bool:
        """ì„¤ì • ê²€ì¦"""
        try:
            # í•„ìˆ˜ ì„¤ì • í™•ì¸
            if self.current_settings.get('strategy_enabled', False):
                if not self.current_settings.get('timeframe'):
                    raise ValidationError("ì°¨íŠ¸ ì£¼ê¸°ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
                
                # ì¡°ê±´ë³„ ê²€ì¦
                if self.current_settings.get('moving_average_enabled', False):
                    self._validate_moving_average_settings()
                
                if self.current_settings.get('price_channel_enabled', False):
                    self._validate_price_channel_settings()
            
            return True
            
        except ValidationError as e:
            self.validation_failed.emit(str(e))
            return False
    
    def get_settings(self) -> Dict[str, Any]:
        """í˜„ì¬ ì„¤ì • ë°˜í™˜"""
        return self.current_settings.copy()
    
    def apply_settings(self, settings: Dict[str, Any]) -> None:
        """ì„¤ì • ì ìš©"""
        try:
            # ì„¤ì • ê²€ì¦
            validated_settings = self._validate_and_normalize_settings(settings)
            
            # UI ì—…ë°ì´íŠ¸
            self._update_ui_from_settings(validated_settings)
            
            # ë‚´ë¶€ ìƒíƒœ ì—…ë°ì´íŠ¸
            self.current_settings = validated_settings
            
            # ë³€ê²½ ì•Œë¦¼
            self.settings_changed.emit(self.current_settings.copy())
            
        except Exception as e:
            self.validation_failed.emit(f"ì„¤ì • ì ìš© ì‹¤íŒ¨: {str(e)}")
```

**Web ëª¨ë“ˆ í‘œì¤€ (Claude Web)**

ì›¹ APIëŠ” RESTful ì„¤ê³„ ì›ì¹™ì„ ë”°ë¥´ë©°, ë³´ì•ˆê³¼ ì„±ëŠ¥ì„ ì¤‘ì‹œí•©ë‹ˆë‹¤:

```python
# ì˜ˆì‹œ: ê±°ë˜ API ì—”ë“œí¬ì¸íŠ¸
@api_bp.route('/trading/entry-conditions', methods=['POST'])
@jwt_required()
@validate_json_schema(entry_conditions_schema)
def update_entry_conditions():
    """
    ì§„ì… ì¡°ê±´ ì„¤ì •ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
    
    Request Body:
        {
            "strategy_enabled": bool,
            "timeframe": str,
            "moving_average": {
                "enabled": bool,
                "condition_type": str,
                "custom_conditions": [...]
            },
            "price_channel": {
                "enabled": bool,
                "indicator_type": str,
                "periods": int
            }
        }
    
    Returns:
        200: ì„¤ì • ì—…ë°ì´íŠ¸ ì„±ê³µ
        400: ì˜ëª»ëœ ìš”ì²­ ë°ì´í„°
        401: ì¸ì¦ ì‹¤íŒ¨
        500: ì„œë²„ ì˜¤ë¥˜
    """
    try:
        user_id = get_jwt_identity()
        request_data = request.get_json()
        
        # 1. ìš”ì²­ ë°ì´í„° ê²€ì¦ ë° ì •ê·œí™”
        validated_data = _validate_entry_conditions(request_data)
        
        # 2. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì‹¤í–‰
        result = trading_service.update_entry_conditions(user_id, validated_data)
        
        if result.success:
            # 3. ì„±ê³µ ì‘ë‹µ
            response_data = {
                'success': True,
                'message': 'Entry conditions updated successfully',
                'data': {
                    'updated_at': datetime.utcnow().isoformat(),
                    'settings': result.settings
                }
            }
            
            # 4. ì‹¤ì‹œê°„ ì•Œë¦¼ (WebSocket)
            socketio.emit(
                'entry_conditions_updated', 
                response_data['data'], 
                room=f'user_{user_id}'
            )
            
            return jsonify(response_data), 200
        else:
            # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì˜¤ë¥˜
            return jsonify({
                'success': False,
                'error': result.error_message,
                'error_code': result.error_code
            }), 400
            
    except ValidationError as e:
        logger.warning(f"Validation error for user {user_id}: {e}")
        return jsonify({
            'success': False,
            'error': 'Invalid request data',
            'details': e.messages
        }), 400
        
    except AuthenticationError as e:
        logger.warning(f"Authentication error: {e}")
        return jsonify({
            'success': False,
            'error': 'Authentication failed'
        }), 401
        
    except Exception as e:
        logger.error(f"Unexpected error in update_entry_conditions: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': 'Internal server error'
        }), 500

def _validate_entry_conditions(data: Dict[str, Any]) -> Dict[str, Any]:
    """ì§„ì… ì¡°ê±´ ë°ì´í„° ê²€ì¦ ë° ì •ê·œí™”"""
    validated = {}
    
    # ì „ëµ í™œì„±í™” ê²€ì¦
    validated['strategy_enabled'] = bool(data.get('strategy_enabled', False))
    
    # ì°¨íŠ¸ ì£¼ê¸° ê²€ì¦
    timeframe = data.get('timeframe', '1ë¶„')
    if timeframe not in SUPPORTED_TIMEFRAMES:
        raise ValidationError(f"Unsupported timeframe: {timeframe}")
    validated['timeframe'] = timeframe
    
    # ì´ë™í‰ê·  ì„¤ì • ê²€ì¦
    if 'moving_average' in data:
        validated['moving_average'] = _validate_moving_average_config(
            data['moving_average']
        )
    
    # Price Channel ì„¤ì • ê²€ì¦
    if 'price_channel' in data:
        validated['price_channel'] = _validate_price_channel_config(
            data['price_channel']
        )
    
    return validated

# WebSocket ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
@socketio.on('subscribe_trading_updates')
@jwt_required()
def handle_subscribe_trading_updates():
    """ê±°ë˜ ì—…ë°ì´íŠ¸ êµ¬ë…"""
    try:
        user_id = get_jwt_identity()
        room = f'user_{user_id}'
        
        join_room(room)
        
        emit('subscription_confirmed', {
            'channel': 'trading_updates',
            'room': room,
            'timestamp': datetime.utcnow().isoformat()
        })
        
        logger.info(f"User {user_id} subscribed to trading updates")
        
    except Exception as e:
        logger.error(f"Error in subscribe_trading_updates: {e}")
        emit('error', {'message': 'Subscription failed'})
```

### 4.2 ì½”ë“œ í’ˆì§ˆ ê²€ì¦ í”„ë¡œì„¸ìŠ¤

**ìë™í™”ëœ í’ˆì§ˆ ê²€ì¦**

ëª¨ë“  ì½”ë“œëŠ” ì»¤ë°‹ ì „ì— ë‹¤ìŒ ê²€ì¦ ê³¼ì •ì„ ê±°ì¹©ë‹ˆë‹¤:

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/psf/black
    rev: 22.3.0
    hooks:
      - id: black
        language_version: python3.9

  - repo: https://github.com/pycqa/isort
    rev: 5.10.1
    hooks:
      - id: isort
        args: ["--profile", "black"]

  - repo: https://github.com/pycqa/flake8
    rev: 4.0.1
    hooks:
      - id: flake8
        additional_dependencies: [flake8-docstrings, flake8-import-order]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v0.950
    hooks:
      - id: mypy
        additional_dependencies: [types-requests]

  - repo: local
    hooks:
      - id: pytest
        name: pytest
        entry: pytest
        language: system
        args: ["--cov=src", "--cov-min=80"]
        pass_filenames: false
```

**ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸**

ê° Claude ì—ì´ì „íŠ¸ëŠ” ë‹¤ìŒ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì½”ë“œ ë¦¬ë·°ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤:

```markdown
## ì½”ë“œ ë¦¬ë·° ì²´í¬ë¦¬ìŠ¤íŠ¸

### ê¸°ëŠ¥ì„± (Functionality)
- [ ] ìš”êµ¬ì‚¬í•­ì„ ì •í™•íˆ êµ¬í˜„í–ˆëŠ”ê°€?
- [ ] ì—£ì§€ ì¼€ì´ìŠ¤ê°€ ì ì ˆíˆ ì²˜ë¦¬ë˜ì—ˆëŠ”ê°€?
- [ ] ì—ëŸ¬ ì²˜ë¦¬ê°€ ì™„ì „í•œê°€?
- [ ] ì„±ëŠ¥ìƒ ë¬¸ì œê°€ ì—†ëŠ”ê°€?

### ì„¤ê³„ (Design)
- [ ] SOLID ì›ì¹™ì„ ì¤€ìˆ˜í•˜ëŠ”ê°€?
- [ ] ì ì ˆí•œ ë””ìì¸ íŒ¨í„´ì„ ì‚¬ìš©í–ˆëŠ”ê°€?
- [ ] ëª¨ë“ˆ ê°„ ê²°í•©ë„ê°€ ë‚®ì€ê°€?
- [ ] í™•ì¥ì„±ì„ ê³ ë ¤í–ˆëŠ”ê°€?

### ê°€ë…ì„± (Readability)
- [ ] ë³€ìˆ˜ëª…ê³¼ í•¨ìˆ˜ëª…ì´ ëª…í™•í•œê°€?
- [ ] ì£¼ì„ì´ ì ì ˆíˆ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] ì½”ë“œ êµ¬ì¡°ê°€ ë…¼ë¦¬ì ì¸ê°€?
- [ ] ë³µì¡í•œ ë¡œì§ì´ ì ì ˆíˆ ë¶„í•´ë˜ì—ˆëŠ”ê°€?

### í…ŒìŠ¤íŠ¸ (Testing)
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ê°€ ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ê°€ 80% ì´ìƒì¸ê°€?
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•œ ê²½ìš° ì‘ì„±ë˜ì—ˆëŠ”ê°€?
- [ ] í…ŒìŠ¤íŠ¸ê°€ ë…ë¦½ì ì´ê³  ë°˜ë³µ ê°€ëŠ¥í•œê°€?

### ë³´ì•ˆ (Security)
- [ ] ì…ë ¥ ê²€ì¦ì´ ì ì ˆí•œê°€?
- [ ] ë¯¼ê°í•œ ì •ë³´ê°€ ë…¸ì¶œë˜ì§€ ì•ŠëŠ”ê°€?
- [ ] ì¸ì¦/ê¶Œí•œ ê²€ì‚¬ê°€ ì ì ˆí•œê°€?
- [ ] SQL ì¸ì ì…˜ ë“± ë³´ì•ˆ ì·¨ì•½ì ì´ ì—†ëŠ”ê°€?
```

---

## ğŸ”„ 5. í†µí•© ê°œë°œ í”„ë¡œì„¸ìŠ¤

### 5.1 ê°œë°œ ë¼ì´í”„ì‚¬ì´í´

ë³¸ í”„ë¡œì íŠ¸ëŠ” ì• ìì¼ ë°©ë²•ë¡ ì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ë°˜ë³µì  ê°œë°œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì±„íƒí•©ë‹ˆë‹¤.

**ìŠ¤í”„ë¦°íŠ¸ êµ¬ì¡° (2ì£¼ ë‹¨ìœ„)**

```
Sprint Planning (Day 1)
â”œâ”€â”€ ë°±ë¡œê·¸ ìš°ì„ ìˆœìœ„ ê²€í† 
â”œâ”€â”€ ìŠ¤í”„ë¦°íŠ¸ ëª©í‘œ ì„¤ì •
â”œâ”€â”€ ì‘ì—… ë¶„ë°° (Claude ì—ì´ì „íŠ¸ë³„)
â””â”€â”€ ì˜ì¡´ì„± ë° ì¸í„°í˜ì´ìŠ¤ í˜‘ì˜

Development Phase (Day 2-12)
â”œâ”€â”€ ì¼ì¼ ìŠ¤íƒ ë“œì—… (ë§¤ì¼)
â”œâ”€â”€ ê°œë°œ ë° í…ŒìŠ¤íŠ¸
â”œâ”€â”€ ì½”ë“œ ë¦¬ë·°
â””â”€â”€ í†µí•© í…ŒìŠ¤íŠ¸

Sprint Review & Retrospective (Day 13-14)
â”œâ”€â”€ ë°ëª¨ ë° ê²€í† 
â”œâ”€â”€ íšŒê³  ë° ê°œì„ ì‚¬í•­ ë„ì¶œ
â””â”€â”€ ë‹¤ìŒ ìŠ¤í”„ë¦°íŠ¸ ê³„íš
```

**ë°±ë¡œê·¸ ê´€ë¦¬**

GitHub Issuesë¥¼ í™œìš©í•œ ì²´ê³„ì ì¸ ë°±ë¡œê·¸ ê´€ë¦¬:

```markdown
# Epic: ê±°ë˜ ì—”ì§„ í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„

## User Stories

### US-001: ì´ë™í‰ê·  ì§„ì… ì¡°ê±´
**As a** íŠ¸ë ˆì´ë”  
**I want to** ì´ë™í‰ê·  ê¸°ë°˜ ì§„ì… ì¡°ê±´ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤  
**So that** ê¸°ìˆ ì  ë¶„ì„ì— ê¸°ë°˜í•œ ìë™ ê±°ë˜ê°€ ê°€ëŠ¥í•˜ë‹¤

**Acceptance Criteria:**
- [ ] 4ê°œ ìº”ë“¤ ì´ë™í‰ê·  ê³„ì‚° ê¸°ëŠ¥
- [ ] ë‹¤ì–‘í•œ ì¡°ê±´ íƒ€ì… ì§€ì› (open_above, close_above ë“±)
- [ ] ì‹¤ì‹œê°„ ì¡°ê±´ í‰ê°€ ë° ì‹ í˜¸ ìƒì„±
- [ ] ì„¤ì • UI ì œê³µ
- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 90% ì´ìƒ

**Tasks:**
- [ ] MovingAverageCondition í´ë˜ìŠ¤ êµ¬í˜„ (Claude Core)
- [ ] ì´ë™í‰ê·  ì„¤ì • UI ê°œë°œ (Claude GUI)
- [ ] REST API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„ (Claude Web)
- [ ] ë°ì´í„° ëª¨ë¸ ì„¤ê³„ (Claude Data)
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„± (Claude Test)

**Estimation:** 13 Story Points  
**Priority:** High  
**Sprint:** Sprint 1
```

### 5.2 ì§€ì†ì  í†µí•©/ë°°í¬ (CI/CD)

**GitHub Actions ì›Œí¬í”Œë¡œìš°**

```yaml
# .github/workflows/ci.yml
name: Continuous Integration

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9, 3.10]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v3
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Lint with flake8
      run: |
        flake8 src tests --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 src tests --count --exit-zero --max-complexity=10 --max-line-length=88 --statistics
    
    - name: Type check with mypy
      run: |
        mypy src
    
    - name: Test with pytest
      run: |
        pytest --cov=src --cov-report=xml --cov-min=80
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

  integration-test:
    needs: test
    runs-on: ubuntu-latest
    
    services:
      redis:
        image: redis:6-alpine
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: 3.9
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run integration tests
      run: |
        pytest tests/integration --verbose
      env:
        REDIS_URL: redis://localhost:6379
        TEST_DATABASE_URL: sqlite:///test.db

  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run Bandit security scan
      run: |
        pip install bandit
        bandit -r src -f json -o bandit-report.json
    
    - name: Upload security scan results
      uses: actions/upload-artifact@v3
      with:
        name: bandit-report
        path: bandit-report.json
```

**ë°°í¬ íŒŒì´í”„ë¼ì¸**

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    tags:
      - 'v*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v3
      with:
        python-version: 3.9
    
    - name: Build application
      run: |
        python setup.py sdist bdist_wheel
    
    - name: Build Docker image
      run: |
        docker build -t crypto-autotrade:${{ github.ref_name }} .
        docker tag crypto-autotrade:${{ github.ref_name }} crypto-autotrade:latest
    
    - name: Deploy to staging
      run: |
        # Staging í™˜ê²½ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
        ./scripts/deploy-staging.sh
    
    - name: Run smoke tests
      run: |
        pytest tests/smoke --base-url=https://staging.crypto-autotrade.com
    
    - name: Deploy to production
      if: success()
      run: |
        # Production í™˜ê²½ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
        ./scripts/deploy-production.sh
```

### 5.3 ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

**êµ¬ì¡°í™”ëœ ë¡œê¹…**

```python
# utils/logger.py
import logging
import json
from datetime import datetime
from typing import Dict, Any

class StructuredLogger:
    """êµ¬ì¡°í™”ëœ ë¡œê¹…ì„ ìœ„í•œ í´ë˜ìŠ¤"""
    
    def __init__(self, name: str, level: int = logging.INFO):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)
        
        # JSON í¬ë§·í„° ì„¤ì •
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
    
    def log_trading_event(self, event_type: str, data: Dict[str, Any]) -> None:
        """ê±°ë˜ ì´ë²¤íŠ¸ ë¡œê¹…"""
        log_data = {
            'event_type': event_type,
            'timestamp': datetime.utcnow().isoformat(),
            'data': data
        }
        
        self.logger.info(json.dumps(log_data))
    
    def log_error(self, error: Exception, context: Dict[str, Any] = None) -> None:
        """ì—ëŸ¬ ë¡œê¹…"""
        log_data = {
            'error_type': type(error).__name__,
            'error_message': str(error),
            'timestamp': datetime.utcnow().isoformat(),
            'context': context or {}
        }
        
        self.logger.error(json.dumps(log_data), exc_info=True)

# ì‚¬ìš© ì˜ˆì‹œ
logger = StructuredLogger('trading_engine')

# ê±°ë˜ ì´ë²¤íŠ¸ ë¡œê¹…
logger.log_trading_event('position_opened', {
    'symbol': 'BTCUSDT',
    'side': 'BUY',
    'quantity': 0.1,
    'entry_price': 50000.0
})

# ì—ëŸ¬ ë¡œê¹…
try:
    # ê±°ë˜ ë¡œì§
    pass
except Exception as e:
    logger.log_error(e, {
        'function': 'execute_trade',
        'symbol': 'BTCUSDT',
        'user_id': 'user123'
    })
```

**ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**

```python
# utils/monitoring.py
import time
import psutil
from functools import wraps
from typing import Callable, Any

def monitor_performance(func: Callable) -> Callable:
    """í•¨ìˆ˜ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë°ì½”ë ˆì´í„°"""
    
    @wraps(func)
    def wrapper(*args, **kwargs) -> Any:
        start_time = time.time()
        start_memory = psutil.Process().memory_info().rss
        
        try:
            result = func(*args, **kwargs)
            
            end_time = time.time()
            end_memory = psutil.Process().memory_info().rss
            
            # ì„±ëŠ¥ ë©”íŠ¸ë¦­ ë¡œê¹…
            logger.log_trading_event('performance_metric', {
                'function': func.__name__,
                'execution_time': end_time - start_time,
                'memory_delta': end_memory - start_memory,
                'success': True
            })
            
            return result
            
        except Exception as e:
            end_time = time.time()
            
            logger.log_trading_event('performance_metric', {
                'function': func.__name__,
                'execution_time': end_time - start_time,
                'success': False,
                'error': str(e)
            })
            
            raise
    
    return wrapper

# ì‚¬ìš© ì˜ˆì‹œ
@monitor_performance
async def execute_trading_cycle():
    """ê±°ë˜ ì‚¬ì´í´ ì‹¤í–‰"""
    # ê±°ë˜ ë¡œì§
    pass
```

---

## ğŸ“Š 6. í’ˆì§ˆ ë³´ì¦ ë° í…ŒìŠ¤íŠ¸ ì „ëµ

### 6.1 í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ

ë³¸ í”„ë¡œì íŠ¸ëŠ” í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ êµ¬ì¡°ë¥¼ ë”°ë¼ ë‹¤ì¸µì  í…ŒìŠ¤íŠ¸ ì „ëµì„ êµ¬í˜„í•©ë‹ˆë‹¤.

**ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Unit Tests) - 70%**

ê° í•¨ìˆ˜ì™€ í´ë˜ìŠ¤ì˜ ê°œë³„ ê¸°ëŠ¥ì„ ê²€ì¦í•©ë‹ˆë‹¤:

```python
# tests/unit/test_moving_average_condition.py
import pytest
from unittest.mock import Mock, patch
from datetime import datetime, timedelta

from src.core.conditions.moving_average import MovingAverageCondition
from src.core.models import MarketData, Candle, EntrySignal
from src.core.exceptions import InsufficientDataError, InvalidConfigError

class TestMovingAverageCondition:
    """ì´ë™í‰ê·  ì¡°ê±´ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def sample_candles(self):
        """í…ŒìŠ¤íŠ¸ìš© ìº”ë“¤ ë°ì´í„°"""
        base_time = datetime.utcnow()
        return [
            Candle(
                symbol="BTCUSDT",
                open=50000.0,
                high=51000.0,
                low=49500.0,
                close=50500.0,
                volume=100.0,
                timestamp=base_time - timedelta(minutes=i)
            )
            for i in range(5)
        ]
    
    @pytest.fixture
    def market_data(self, sample_candles):
        """í…ŒìŠ¤íŠ¸ìš© ì‹œì¥ ë°ì´í„°"""
        return MarketData(
            symbol="BTCUSDT",
            candles=sample_candles,
            timestamp=datetime.utcnow()
        )
    
    @pytest.fixture
    def ma_condition(self):
        """ì´ë™í‰ê·  ì¡°ê±´ ì¸ìŠ¤í„´ìŠ¤"""
        config = {
            'condition_type': 'close_above_ma_buy',
            'required_periods': 4,
            'enabled': True
        }
        return MovingAverageCondition(config)
    
    def test_calculate_moving_average_success(self, ma_condition):
        """ì´ë™í‰ê·  ê³„ì‚° ì„±ê³µ í…ŒìŠ¤íŠ¸"""
        prices = [50000.0, 50500.0, 51000.0, 50750.0]
        expected_ma = sum(prices) / len(prices)
        
        result = ma_condition._calculate_moving_average(prices, 4)
        
        assert result == expected_ma
    
    def test_calculate_moving_average_insufficient_data(self, ma_condition):
        """ë°ì´í„° ë¶€ì¡± ì‹œ ì˜ˆì™¸ ë°œìƒ í…ŒìŠ¤íŠ¸"""
        prices = [50000.0, 50500.0]  # 4ê°œ í•„ìš”í•˜ì§€ë§Œ 2ê°œë§Œ ì œê³µ
        
        with pytest.raises(ValueError, match="Expected 4 prices, got 2"):
            ma_condition._calculate_moving_average(prices, 4)
    
    @pytest.mark.asyncio
    async def test_evaluate_condition_buy_signal(self, ma_condition, market_data):
        """ë§¤ìˆ˜ ì‹ í˜¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        # í˜„ì¬ê°€ê°€ ì´ë™í‰ê· ë³´ë‹¤ ë†’ì€ ìƒí™© ì„¤ì •
        market_data.candles[0].close = 52000.0  # í˜„ì¬ ì¢…ê°€
        
        with patch.object(ma_condition, '_calculate_moving_average', return_value=51000.0):
            result = await ma_condition.evaluate_moving_average_condition(
                market_data, 
                ma_condition.config
            )
        
        assert result is not None
        assert isinstance(result, EntrySignal)
        assert result.signal_type == 'BUY'
        assert result.symbol == 'BTCUSDT'
        assert result.confidence > 0
    
    @pytest.mark.asyncio
    async def test_evaluate_condition_no_signal(self, ma_condition, market_data):
        """ì‹ í˜¸ ì—†ìŒ í…ŒìŠ¤íŠ¸"""
        # í˜„ì¬ê°€ê°€ ì´ë™í‰ê· ë³´ë‹¤ ë‚®ì€ ìƒí™© ì„¤ì •
        market_data.candles[0].close = 49000.0  # í˜„ì¬ ì¢…ê°€
        
        with patch.object(ma_condition, '_calculate_moving_average', return_value=51000.0):
            result = await ma_condition.evaluate_moving_average_condition(
                market_data, 
                ma_condition.config
            )
        
        assert result is None
    
    @pytest.mark.asyncio
    async def test_evaluate_condition_insufficient_data_error(self, ma_condition):
        """ë°ì´í„° ë¶€ì¡± ì‹œ ì˜ˆì™¸ ë°œìƒ í…ŒìŠ¤íŠ¸"""
        insufficient_data = MarketData(
            symbol="BTCUSDT",
            candles=[],  # ë¹ˆ ìº”ë“¤ ë°ì´í„°
            timestamp=datetime.utcnow()
        )
        
        with pytest.raises(InsufficientDataError):
            await ma_condition.evaluate_moving_average_condition(
                insufficient_data, 
                ma_condition.config
            )
    
    def test_evaluate_ma_signal_invalid_condition_type(self, ma_condition, sample_candles):
        """ì˜ëª»ëœ ì¡°ê±´ íƒ€ì… í…ŒìŠ¤íŠ¸"""
        candle = sample_candles[0]
        ma_value = 50000.0
        invalid_condition = "invalid_condition_type"
        
        with pytest.raises(InvalidConfigError, match="Unknown condition type"):
            ma_condition._evaluate_ma_signal(candle, ma_value, invalid_condition)
    
    @pytest.mark.parametrize("condition_type,candle_price,ma_value,expected_signal", [
        ("open_above_ma_buy", 51000.0, 50000.0, "BUY"),
        ("open_above_ma_buy", 49000.0, 50000.0, None),
        ("close_above_ma_buy", 51000.0, 50000.0, "BUY"),
        ("close_above_ma_buy", 49000.0, 50000.0, None),
        ("open_below_ma_sell", 49000.0, 50000.0, "SELL"),
        ("open_below_ma_sell", 51000.0, 50000.0, None),
        ("close_below_ma_sell", 49000.0, 50000.0, "SELL"),
        ("close_below_ma_sell", 51000.0, 50000.0, None),
    ])
    def test_evaluate_ma_signal_conditions(
        self, 
        ma_condition, 
        condition_type, 
        candle_price, 
        ma_value, 
        expected_signal
    ):
        """ë‹¤ì–‘í•œ ì¡°ê±´ íƒ€ì…ë³„ ì‹ í˜¸ í‰ê°€ í…ŒìŠ¤íŠ¸"""
        candle = Candle(
            symbol="BTCUSDT",
            open=candle_price,
            high=candle_price + 100,
            low=candle_price - 100,
            close=candle_price,
            volume=100.0,
            timestamp=datetime.utcnow()
        )
        
        result = ma_condition._evaluate_ma_signal(candle, ma_value, condition_type)
        
        assert result == expected_signal
```

**í†µí•© í…ŒìŠ¤íŠ¸ (Integration Tests) - 20%**

ëª¨ë“ˆ ê°„ ìƒí˜¸ì‘ìš©ì„ ê²€ì¦í•©ë‹ˆë‹¤:

```python
# tests/integration/test_trading_engine_integration.py
import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch

from src.core.trading_engine import TradingEngine
from src.core.models import TradingConfig, MarketData, Position
from src.core.api.binance_connector import BinanceConnector
from src.core.risk.risk_manager import RiskManager

@pytest.mark.integration
class TestTradingEngineIntegration:
    """ê±°ë˜ ì—”ì§„ í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    async def trading_engine(self):
        """í†µí•© í…ŒìŠ¤íŠ¸ìš© ê±°ë˜ ì—”ì§„"""
        config = TradingConfig(
            strategy_enabled=True,
            timeframe="1m",
            moving_average_enabled=True,
            moving_average_config={
                'condition_type': 'close_above_ma_buy',
                'required_periods': 4
            }
        )
        
        # Mock ì˜ì¡´ì„± ìƒì„±
        api_connector = Mock(spec=BinanceConnector)
        risk_manager = Mock(spec=RiskManager)
        event_bus = Mock()
        
        engine = TradingEngine(config, api_connector, risk_manager, event_bus)
        
        yield engine
        
        # ì •ë¦¬
        await engine.stop()
    
    @pytest.mark.asyncio
    async def test_full_trading_cycle(self, trading_engine):
        """ì „ì²´ ê±°ë˜ ì‚¬ì´í´ í†µí•© í…ŒìŠ¤íŠ¸"""
        # 1. Mock ì„¤ì •
        mock_market_data = MarketData(
            symbol="BTCUSDT",
            candles=self._create_sample_candles(),
            timestamp=datetime.utcnow()
        )
        
        trading_engine.api_connector.get_latest_market_data = AsyncMock(
            return_value=mock_market_data
        )
        
        trading_engine.risk_manager.validate_entry_signal = Mock(return_value=True)
        trading_engine.risk_manager.calculate_position_size = Mock(return_value=0.1)
        
        trading_engine.api_connector.place_order = AsyncMock(
            return_value=Mock(
                success=True,
                fill_price=50500.0,
                order_id="12345"
            )
        )
        
        # 2. ê±°ë˜ ì‚¬ì´í´ ì‹¤í–‰
        await trading_engine.start()
        
        # ì ì‹œ ëŒ€ê¸°í•˜ì—¬ ë¹„ë™ê¸° ì‘ì—… ì™„ë£Œ
        await asyncio.sleep(0.5)
        
        # 3. ê²€ì¦
        assert len(trading_engine._active_positions) > 0
        
        position = list(trading_engine._active_positions.values())[0]
        assert position.symbol == "BTCUSDT"
        assert position.side == "BUY"
        assert position.size == 0.1
        
        # API í˜¸ì¶œ ê²€ì¦
        trading_engine.api_connector.get_latest_market_data.assert_called()
        trading_engine.api_connector.place_order.assert_called_once()
        
        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ í˜¸ì¶œ ê²€ì¦
        trading_engine.risk_manager.validate_entry_signal.assert_called()
        trading_engine.risk_manager.calculate_position_size.assert_called()
    
    @pytest.mark.asyncio
    async def test_risk_rejection_scenario(self, trading_engine):
        """ë¦¬ìŠ¤í¬ ê±°ë¶€ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸"""
        # Mock ì„¤ì • - ë¦¬ìŠ¤í¬ ë§¤ë‹ˆì €ê°€ ì‹ í˜¸ë¥¼ ê±°ë¶€
        trading_engine.risk_manager.validate_entry_signal = Mock(return_value=False)
        
        mock_market_data = MarketData(
            symbol="BTCUSDT",
            candles=self._create_sample_candles(),
            timestamp=datetime.utcnow()
        )
        
        trading_engine.api_connector.get_latest_market_data = AsyncMock(
            return_value=mock_market_data
        )
        
        # ê±°ë˜ ì‚¬ì´í´ ì‹¤í–‰
        await trading_engine.start()
        await asyncio.sleep(0.5)
        
        # ê²€ì¦ - í¬ì§€ì…˜ì´ ìƒì„±ë˜ì§€ ì•Šì•„ì•¼ í•¨
        assert len(trading_engine._active_positions) == 0
        
        # API ì£¼ë¬¸ í˜¸ì¶œì´ ì—†ì–´ì•¼ í•¨
        trading_engine.api_connector.place_order.assert_not_called()
    
    def _create_sample_candles(self):
        """í…ŒìŠ¤íŠ¸ìš© ìƒ˜í”Œ ìº”ë“¤ ìƒì„±"""
        base_time = datetime.utcnow()
        return [
            Candle(
                symbol="BTCUSDT",
                open=50000.0 + i * 100,
                high=50500.0 + i * 100,
                low=49500.0 + i * 100,
                close=50200.0 + i * 100,
                volume=100.0,
                timestamp=base_time - timedelta(minutes=i)
            )
            for i in range(5)
        ]
```

**E2E í…ŒìŠ¤íŠ¸ (End-to-End Tests) - 10%**

ì „ì²´ ì‹œìŠ¤í…œì˜ ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤:

```python
# tests/e2e/test_trading_workflow.py
import pytest
import asyncio
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

@pytest.mark.e2e
class TestTradingWorkflowE2E:
    """ê±°ë˜ ì›Œí¬í”Œë¡œìš° E2E í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture(scope="class")
    def browser(self):
        """ë¸Œë¼ìš°ì € ì¸ìŠ¤í„´ìŠ¤"""
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        
        driver = webdriver.Chrome(options=options)
        driver.implicitly_wait(10)
        
        yield driver
        
        driver.quit()
    
    @pytest.fixture
    def authenticated_user(self, browser):
        """ì¸ì¦ëœ ì‚¬ìš©ì ì„¸ì…˜"""
        # ë¡œê·¸ì¸ í˜ì´ì§€ ì ‘ì†
        browser.get("http://localhost:5000/login")
        
        # ë¡œê·¸ì¸ ì •ë³´ ì…ë ¥
        username_input = browser.find_element(By.ID, "username")
        password_input = browser.find_element(By.ID, "password")
        
        username_input.send_keys("testuser")
        password_input.send_keys("testpass123")
        
        # ë¡œê·¸ì¸ ë²„íŠ¼ í´ë¦­
        login_button = browser.find_element(By.ID, "login-button")
        login_button.click()
        
        # ëŒ€ì‹œë³´ë“œ ë¡œë”© ëŒ€ê¸°
        WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.ID, "trading-dashboard"))
        )
        
        return browser
    
    def test_complete_trading_setup_workflow(self, authenticated_user):
        """ì™„ì „í•œ ê±°ë˜ ì„¤ì • ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸"""
        browser = authenticated_user
        
        # 1. ì§„ì… ì„¤ì • íƒ­ìœ¼ë¡œ ì´ë™
        entry_settings_tab = browser.find_element(By.ID, "entry-settings-tab")
        entry_settings_tab.click()
        
        # 2. ì „ëµ ì—°ë™ í™œì„±í™”
        strategy_enabled_checkbox = WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.ID, "strategy-enabled"))
        )
        strategy_enabled_checkbox.click()
        
        # 3. ì°¨íŠ¸ ì£¼ê¸° ì„¤ì •
        timeframe_select = browser.find_element(By.ID, "timeframe-select")
        timeframe_select.click()
        
        timeframe_option = browser.find_element(By.XPATH, "//option[@value='1m']")
        timeframe_option.click()
        
        # 4. ì´ë™í‰ê·  ì¡°ê±´ í™œì„±í™”
        ma_enabled_checkbox = browser.find_element(By.ID, "ma-enabled")
        ma_enabled_checkbox.click()
        
        # 5. ì´ë™í‰ê·  ì¡°ê±´ íƒ€ì… ì„ íƒ
        ma_condition_select = browser.find_element(By.ID, "ma-condition-type")
        ma_condition_select.click()
        
        ma_condition_option = browser.find_element(
            By.XPATH, "//option[@value='close_above_ma_buy']"
        )
        ma_condition_option.click()
        
        # 6. ì„¤ì • ì €ì¥
        save_button = browser.find_element(By.ID, "save-settings")
        save_button.click()
        
        # 7. ì„±ê³µ ë©”ì‹œì§€ í™•ì¸
        success_message = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.CLASS_NAME, "success-message"))
        )
        
        assert "ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤" in success_message.text
        
        # 8. ì²­ì‚° ì„¤ì • íƒ­ìœ¼ë¡œ ì´ë™
        exit_settings_tab = browser.find_element(By.ID, "exit-settings-tab")
        exit_settings_tab.click()
        
        # 9. PCS ì²­ì‚° í™œì„±í™”
        pcs_enabled_checkbox = WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.ID, "pcs-enabled"))
        )
        pcs_enabled_checkbox.click()
        
        # 10. PCS ë‹¨ê³„ ì„¤ì •
        pcs_stages_input = browser.find_element(By.ID, "pcs-stages")
        pcs_stages_input.clear()
        pcs_stages_input.send_keys("1,2,3")
        
        # 11. ì²­ì‚° ì„¤ì • ì €ì¥
        save_exit_button = browser.find_element(By.ID, "save-exit-settings")
        save_exit_button.click()
        
        # 12. ê±°ë˜ ì‹œì‘
        start_trading_button = browser.find_element(By.ID, "start-trading")
        start_trading_button.click()
        
        # 13. í™•ì¸ ëŒ€í™”ìƒì ì²˜ë¦¬
        confirm_button = WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.ID, "confirm-start-trading"))
        )
        confirm_button.click()
        
        # 14. ê±°ë˜ ìƒíƒœ í™•ì¸
        trading_status = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.ID, "trading-status"))
        )
        
        assert "ê±°ë˜ ì¤‘" in trading_status.text
        
        # 15. ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸ í™•ì¸
        position_table = browser.find_element(By.ID, "positions-table")
        
        # ì ì‹œ ëŒ€ê¸°í•˜ì—¬ ì‹¤ì‹œê°„ ë°ì´í„° ë¡œë”©
        import time
        time.sleep(5)
        
        # í¬ì§€ì…˜ ë°ì´í„°ê°€ í‘œì‹œë˜ëŠ”ì§€ í™•ì¸ (ì‹¤ì œ ê±°ë˜ê°€ ë°œìƒí–ˆë‹¤ë©´)
        position_rows = position_table.find_elements(By.TAG_NAME, "tr")
        
        # ìµœì†Œí•œ í—¤ë” í–‰ì€ ìˆì–´ì•¼ í•¨
        assert len(position_rows) >= 1
    
    def test_emergency_stop_workflow(self, authenticated_user):
        """ê¸´ê¸‰ ì²­ì‚° ì›Œí¬í”Œë¡œìš° í…ŒìŠ¤íŠ¸"""
        browser = authenticated_user
        
        # 1. ê¸´ê¸‰ ì²­ì‚° ë²„íŠ¼ ì°¾ê¸°
        emergency_button = browser.find_element(By.ID, "emergency-stop")
        
        # 2. ê¸´ê¸‰ ì²­ì‚° ë²„íŠ¼ í´ë¦­
        emergency_button.click()
        
        # 3. í™•ì¸ ëŒ€í™”ìƒì ëŒ€ê¸°
        confirm_dialog = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.ID, "emergency-confirm-dialog"))
        )
        
        # 4. í™•ì¸ ë²„íŠ¼ í´ë¦­
        confirm_emergency = browser.find_element(By.ID, "confirm-emergency-stop")
        confirm_emergency.click()
        
        # 5. ê¸´ê¸‰ ì²­ì‚° ì™„ë£Œ ë©”ì‹œì§€ í™•ì¸
        emergency_message = WebDriverWait(browser, 15).until(
            EC.presence_of_element_located((By.CLASS_NAME, "emergency-message"))
        )
        
        assert "ê¸´ê¸‰ ì²­ì‚°ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤" in emergency_message.text
        
        # 6. ê±°ë˜ ìƒíƒœê°€ ì¤‘ì§€ë¨ìœ¼ë¡œ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸
        trading_status = browser.find_element(By.ID, "trading-status")
        assert "ê±°ë˜ ì¤‘ì§€" in trading_status.text
```

### 6.2 ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

**ë¶€í•˜ í…ŒìŠ¤íŠ¸**

```python
# tests/performance/test_load.py
import pytest
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
from unittest.mock import Mock, AsyncMock

from src.core.trading_engine import TradingEngine
from src.core.models import MarketData

@pytest.mark.performance
class TestTradingEnginePerformance:
    """ê±°ë˜ ì—”ì§„ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    
    @pytest.mark.asyncio
    async def test_concurrent_signal_processing(self):
        """ë™ì‹œ ì‹ í˜¸ ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        # í…ŒìŠ¤íŠ¸ ì„¤ì •
        num_concurrent_requests = 100
        max_response_time = 1.0  # 1ì´ˆ
        
        # Mock ê±°ë˜ ì—”ì§„ ìƒì„±
        trading_engine = Mock()
        trading_engine.evaluate_entry_conditions = AsyncMock()
        
        # í…ŒìŠ¤íŠ¸ ë°ì´í„° ìƒì„±
        market_data = MarketData(
            symbol="BTCUSDT",
            candles=self._create_sample_candles(),
            timestamp=datetime.utcnow()
        )
        
        # ë™ì‹œ ìš”ì²­ ì‹¤í–‰
        start_time = time.time()
        
        tasks = [
            trading_engine.evaluate_entry_conditions(market_data)
            for _ in range(num_concurrent_requests)
        ]
        
        results = await asyncio.gather(*tasks)
        
        end_time = time.time()
        total_time = end_time - start_time
        
        # ì„±ëŠ¥ ê²€ì¦
        assert total_time < max_response_time
        assert len(results) == num_concurrent_requests
        
        # ì²˜ë¦¬ëŸ‰ ê³„ì‚°
        throughput = num_concurrent_requests / total_time
        print(f"Throughput: {throughput:.2f} requests/second")
        
        # ìµœì†Œ ì²˜ë¦¬ëŸ‰ ìš”êµ¬ì‚¬í•­ ê²€ì¦
        assert throughput > 50  # ì´ˆë‹¹ 50ê°œ ì´ìƒ ì²˜ë¦¬
    
    @pytest.mark.asyncio
    async def test_memory_usage_under_load(self):
        """ë¶€í•˜ ìƒí™©ì—ì„œ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í…ŒìŠ¤íŠ¸"""
        import psutil
        import gc
        
        # ì´ˆê¸° ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¸¡ì •
        process = psutil.Process()
        initial_memory = process.memory_info().rss
        
        # ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œë®¬ë ˆì´ì…˜
        trading_engine = Mock()
        
        for i in range(1000):
            market_data = MarketData(
                symbol=f"BTC{i}USDT",
                candles=self._create_sample_candles(),
                timestamp=datetime.utcnow()
            )
            
            # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•œ ì£¼ê¸°ì  ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
            if i % 100 == 0:
                gc.collect()
        
        # ìµœì¢… ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¸¡ì •
        final_memory = process.memory_info().rss
        memory_increase = final_memory - initial_memory
        
        # ë©”ëª¨ë¦¬ ì¦ê°€ëŸ‰ ê²€ì¦ (100MB ì´í•˜)
        max_memory_increase = 100 * 1024 * 1024  # 100MB
        assert memory_increase < max_memory_increase
        
        print(f"Memory increase: {memory_increase / 1024 / 1024:.2f} MB")
```

---

## ğŸš€ 7. ë°°í¬ ë° ìš´ì˜

### 7.1 ë°°í¬ ì „ëµ

**Blue-Green ë°°í¬**

ì•ˆì „í•œ ë¬´ì¤‘ë‹¨ ë°°í¬ë¥¼ ìœ„í•´ Blue-Green ë°°í¬ ì „ëµì„ ì±„íƒí•©ë‹ˆë‹¤:

```bash
#!/bin/bash
# scripts/deploy-blue-green.sh

set -e

BLUE_PORT=5000
GREEN_PORT=5001
CURRENT_ENV=""
NEW_ENV=""

# í˜„ì¬ í™œì„± í™˜ê²½ í™•ì¸
check_current_environment() {
    if curl -f http://localhost:$BLUE_PORT/health > /dev/null 2>&1; then
        CURRENT_ENV="blue"
        NEW_ENV="green"
        NEW_PORT=$GREEN_PORT
    else
        CURRENT_ENV="green"
        NEW_ENV="blue"
        NEW_PORT=$BLUE_PORT
    fi
    
    echo "Current environment: $CURRENT_ENV"
    echo "Deploying to: $NEW_ENV (port $NEW_PORT)"
}

# ìƒˆ í™˜ê²½ì— ë°°í¬
deploy_new_environment() {
    echo "Building new Docker image..."
    docker build -t crypto-autotrade:$NEW_ENV .
    
    echo "Starting new environment..."
    docker run -d \
        --name crypto-autotrade-$NEW_ENV \
        -p $NEW_PORT:5000 \
        -e DATABASE_URL=$DATABASE_URL \
        -e REDIS_URL=$REDIS_URL \
        crypto-autotrade:$NEW_ENV
    
    # í—¬ìŠ¤ì²´í¬ ëŒ€ê¸°
    echo "Waiting for new environment to be ready..."
    for i in {1..30}; do
        if curl -f http://localhost:$NEW_PORT/health > /dev/null 2>&1; then
            echo "New environment is ready!"
            return 0
        fi
        sleep 10
    done
    
    echo "New environment failed to start"
    exit 1
}

# ìŠ¤ëª¨í¬ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
run_smoke_tests() {
    echo "Running smoke tests..."
    pytest tests/smoke --base-url=http://localhost:$NEW_PORT
    
    if [ $? -ne 0 ]; then
        echo "Smoke tests failed, rolling back..."
        docker stop crypto-autotrade-$NEW_ENV
        docker rm crypto-autotrade-$NEW_ENV
        exit 1
    fi
}

# íŠ¸ë˜í”½ ì „í™˜
switch_traffic() {
    echo "Switching traffic to new environment..."
    
    # ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì • ì—…ë°ì´íŠ¸ (ì˜ˆ: nginx)
    sed -i "s/localhost:$CURRENT_PORT/localhost:$NEW_PORT/g" /etc/nginx/sites-available/crypto-autotrade
    nginx -s reload
    
    # ê¸°ì¡´ í™˜ê²½ ì •ë¦¬
    sleep 30  # ê¸°ì¡´ ìš”ì²­ ì²˜ë¦¬ ì™„ë£Œ ëŒ€ê¸°
    docker stop crypto-autotrade-$CURRENT_ENV
    docker rm crypto-autotrade-$CURRENT_ENV
    
    echo "Deployment completed successfully!"
}

# ë©”ì¸ ì‹¤í–‰
main() {
    check_current_environment
    deploy_new_environment
    run_smoke_tests
    switch_traffic
}

main "$@"
```

### 7.2 ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼

**Prometheus + Grafana ëª¨ë‹ˆí„°ë§**

```python
# src/utils/metrics.py
from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time
from functools import wraps

# ë©”íŠ¸ë¦­ ì •ì˜
TRADE_COUNTER = Counter('trades_total', 'Total number of trades', ['symbol', 'side'])
TRADE_DURATION = Histogram('trade_duration_seconds', 'Time spent processing trades')
ACTIVE_POSITIONS = Gauge('active_positions_total', 'Number of active positions')
API_REQUESTS = Counter('api_requests_total', 'Total API requests', ['endpoint', 'status'])
ERROR_COUNTER = Counter('errors_total', 'Total number of errors', ['error_type'])

def track_trade_metrics(func):
    """ê±°ë˜ ë©”íŠ¸ë¦­ ì¶”ì  ë°ì½”ë ˆì´í„°"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = await func(*args, **kwargs)
            
            # ì„±ê³µí•œ ê±°ë˜ ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            if result and hasattr(result, 'symbol') and hasattr(result, 'side'):
                TRADE_COUNTER.labels(
                    symbol=result.symbol, 
                    side=result.side
                ).inc()
            
            return result
            
        except Exception as e:
            ERROR_COUNTER.labels(error_type=type(e).__name__).inc()
            raise
            
        finally:
            TRADE_DURATION.observe(time.time() - start_time)
    
    return wrapper

def start_metrics_server(port=8000):
    """ë©”íŠ¸ë¦­ ì„œë²„ ì‹œì‘"""
    start_http_server(port)
    print(f"Metrics server started on port {port}")

# ì‚¬ìš© ì˜ˆì‹œ
@track_trade_metrics
async def execute_trade(signal):
    # ê±°ë˜ ì‹¤í–‰ ë¡œì§
    pass
```

**ì•Œë¦¼ ì‹œìŠ¤í…œ**

```python
# src/utils/alerts.py
import smtplib
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, Any

class AlertManager:
    """ì•Œë¦¼ ê´€ë¦¬ì"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.email_config = config.get('email', {})
        self.slack_config = config.get('slack', {})
        self.telegram_config = config.get('telegram', {})
    
    async def send_critical_alert(self, title: str, message: str, data: Dict[str, Any] = None):
        """ì¤‘ìš” ì•Œë¦¼ ì „ì†¡"""
        alert_data = {
            'title': title,
            'message': message,
            'timestamp': datetime.utcnow().isoformat(),
            'severity': 'CRITICAL',
            'data': data or {}
        }
        
        # ëª¨ë“  ì±„ë„ë¡œ ì•Œë¦¼ ì „ì†¡
        await asyncio.gather(
            self._send_email_alert(alert_data),
            self._send_slack_alert(alert_data),
            self._send_telegram_alert(alert_data),
            return_exceptions=True
        )
    
    async def send_warning_alert(self, title: str, message: str, data: Dict[str, Any] = None):
        """ê²½ê³  ì•Œë¦¼ ì „ì†¡"""
        alert_data = {
            'title': title,
            'message': message,
            'timestamp': datetime.utcnow().isoformat(),
            'severity': 'WARNING',
            'data': data or {}
        }
        
        # Slackê³¼ Telegramìœ¼ë¡œë§Œ ì „ì†¡
        await asyncio.gather(
            self._send_slack_alert(alert_data),
            self._send_telegram_alert(alert_data),
            return_exceptions=True
        )
    
    async def _send_email_alert(self, alert_data: Dict[str, Any]):
        """ì´ë©”ì¼ ì•Œë¦¼ ì „ì†¡"""
        if not self.email_config.get('enabled', False):
            return
        
        try:
            msg = MIMEMultipart()
            msg['From'] = self.email_config['from']
            msg['To'] = ', '.join(self.email_config['to'])
            msg['Subject'] = f"[{alert_data['severity']}] {alert_data['title']}"
            
            body = f"""
            ì•Œë¦¼ ì‹œê°„: {alert_data['timestamp']}
            ì‹¬ê°ë„: {alert_data['severity']}
            ì œëª©: {alert_data['title']}
            
            ë©”ì‹œì§€:
            {alert_data['message']}
            
            ì¶”ê°€ ë°ì´í„°:
            {json.dumps(alert_data['data'], indent=2, ensure_ascii=False)}
            """
            
            msg.attach(MIMEText(body, 'plain', 'utf-8'))
            
            server = smtplib.SMTP(self.email_config['smtp_host'], self.email_config['smtp_port'])
            server.starttls()
            server.login(self.email_config['username'], self.email_config['password'])
            server.send_message(msg)
            server.quit()
            
        except Exception as e:
            logger.error(f"Failed to send email alert: {e}")
    
    async def _send_slack_alert(self, alert_data: Dict[str, Any]):
        """Slack ì•Œë¦¼ ì „ì†¡"""
        if not self.slack_config.get('enabled', False):
            return
        
        try:
            webhook_url = self.slack_config['webhook_url']
            
            color = '#ff0000' if alert_data['severity'] == 'CRITICAL' else '#ffaa00'
            
            payload = {
                'attachments': [{
                    'color': color,
                    'title': f"[{alert_data['severity']}] {alert_data['title']}",
                    'text': alert_data['message'],
                    'fields': [
                        {
                            'title': 'ì‹œê°„',
                            'value': alert_data['timestamp'],
                            'short': True
                        },
                        {
                            'title': 'ì‹¬ê°ë„',
                            'value': alert_data['severity'],
                            'short': True
                        }
                    ],
                    'footer': 'Crypto AutoTrade System',
                    'ts': int(time.time())
                }]
            }
            
            response = requests.post(webhook_url, json=payload, timeout=10)
            response.raise_for_status()
            
        except Exception as e:
            logger.error(f"Failed to send Slack alert: {e}")
    
    async def _send_telegram_alert(self, alert_data: Dict[str, Any]):
        """í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡"""
        if not self.telegram_config.get('enabled', False):
            return
        
        try:
            bot_token = self.telegram_config['bot_token']
            chat_id = self.telegram_config['chat_id']
            
            message = f"""
ğŸš¨ *{alert_data['severity']}* ì•Œë¦¼

*ì œëª©:* {alert_data['title']}
*ì‹œê°„:* {alert_data['timestamp']}

*ë©”ì‹œì§€:*
{alert_data['message']}
            """
            
            url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            payload = {
                'chat_id': chat_id,
                'text': message,
                'parse_mode': 'Markdown'
            }
            
            response = requests.post(url, json=payload, timeout=10)
            response.raise_for_status()
            
        except Exception as e:
            logger.error(f"Failed to send Telegram alert: {e}")

# ì‚¬ìš© ì˜ˆì‹œ
alert_manager = AlertManager(config['alerts'])

# ì¤‘ìš” ì•Œë¦¼
await alert_manager.send_critical_alert(
    "ê±°ë˜ ì‹œìŠ¤í…œ ì˜¤ë¥˜",
    "API ì—°ê²°ì´ ëŠì–´ì ¸ ê±°ë˜ê°€ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.",
    {"error_code": "API_CONNECTION_LOST", "retry_count": 3}
)

# ê²½ê³  ì•Œë¦¼
await alert_manager.send_warning_alert(
    "ë†’ì€ ìŠ¬ë¦¬í”¼ì§€ ê°ì§€",
    "BTCUSDTì—ì„œ ì˜ˆìƒë³´ë‹¤ ë†’ì€ ìŠ¬ë¦¬í”¼ì§€ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
    {"symbol": "BTCUSDT", "expected_slippage": 0.1, "actual_slippage": 0.5}
)
```

---

## ğŸ“š 8. ë¬¸ì„œí™” ë° ì§€ì‹ ê´€ë¦¬

### 8.1 API ë¬¸ì„œí™”

**OpenAPI/Swagger ë¬¸ì„œ ìë™ ìƒì„±**

```python
# src/web/api_docs.py
from flask import Flask
from flask_restx import Api, Resource, fields
from flask_restx import Namespace

# API ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì •ì˜
trading_ns = Namespace('trading', description='ê±°ë˜ ê´€ë ¨ API')

# ëª¨ë¸ ì •ì˜
entry_condition_model = trading_ns.model('EntryCondition', {
    'strategy_enabled': fields.Boolean(required=True, description='ì „ëµ í™œì„±í™” ì—¬ë¶€'),
    'timeframe': fields.String(required=True, description='ì°¨íŠ¸ ì£¼ê¸°', enum=['1m', '5m', '15m', '1h', '4h', '1d']),
    'moving_average': fields.Nested(trading_ns.model('MovingAverage', {
        'enabled': fields.Boolean(description='ì´ë™í‰ê·  ì¡°ê±´ í™œì„±í™”'),
        'condition_type': fields.String(description='ì¡°ê±´ íƒ€ì…', enum=['open_above_ma_buy', 'close_above_ma_buy']),
        'custom_conditions': fields.List(fields.String(), description='ì‚¬ìš©ì ì •ì˜ ì¡°ê±´')
    })),
    'price_channel': fields.Nested(trading_ns.model('PriceChannel', {
        'enabled': fields.Boolean(description='Price Channel ì¡°ê±´ í™œì„±í™”'),
        'indicator_type': fields.String(description='ì§€í‘œ íƒ€ì…'),
        'periods': fields.Integer(description='ê¸°ê°„')
    }))
})

position_model = trading_ns.model('Position', {
    'id': fields.String(required=True, description='í¬ì§€ì…˜ ID'),
    'symbol': fields.String(required=True, description='ì‹¬ë³¼'),
    'side': fields.String(required=True, description='ë§¤ìˆ˜/ë§¤ë„', enum=['BUY', 'SELL']),
    'size': fields.Float(required=True, description='í¬ì§€ì…˜ í¬ê¸°'),
    'entry_price': fields.Float(required=True, description='ì§„ì…ê°€'),
    'current_price': fields.Float(description='í˜„ì¬ê°€'),
    'pnl': fields.Float(description='ì†ìµ'),
    'created_at': fields.DateTime(description='ìƒì„± ì‹œê°„')
})

@trading_ns.route('/entry-conditions')
class EntryConditions(Resource):
    @trading_ns.doc('update_entry_conditions')
    @trading_ns.expect(entry_condition_model)
    @trading_ns.response(200, 'Success')
    @trading_ns.response(400, 'Invalid request data')
    @trading_ns.response(401, 'Authentication required')
    def post(self):
        """
        ì§„ì… ì¡°ê±´ ì„¤ì • ì—…ë°ì´íŠ¸
        
        ì´ë™í‰ê· , Price Channel ë“±ì˜ ì§„ì… ì¡°ê±´ì„ ì„¤ì •í•©ë‹ˆë‹¤.
        """
        pass

@trading_ns.route('/positions')
class Positions(Resource):
    @trading_ns.doc('get_positions')
    @trading_ns.marshal_list_with(position_model)
    @trading_ns.param('symbol', 'ì‹¬ë³¼ í•„í„° (ì„ íƒì‚¬í•­)')
    @trading_ns.param('status', 'ìƒíƒœ í•„í„°', enum=['active', 'closed', 'all'], default='active')
    @trading_ns.param('limit', 'ê²°ê³¼ ìˆ˜ ì œí•œ', type=int, default=50)
    @trading_ns.param('offset', 'ì˜¤í”„ì…‹', type=int, default=0)
    def get(self):
        """
        í¬ì§€ì…˜ ëª©ë¡ ì¡°íšŒ
        
        í™œì„± í¬ì§€ì…˜ ë˜ëŠ” ì „ì²´ í¬ì§€ì…˜ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
        """
        pass

# Flask ì•±ì— ë“±ë¡
def create_api_docs(app: Flask):
    api = Api(
        app,
        version='1.0',
        title='Crypto AutoTrade API',
        description='ì•”í˜¸í™”í ìë™ë§¤ë§¤ ì‹œìŠ¤í…œ API',
        doc='/docs/'
    )
    
    api.add_namespace(trading_ns, path='/api/trading')
    
    return api
```

### 8.2 ì‚¬ìš©ì ê°€ì´ë“œ

**ë§ˆí¬ë‹¤ìš´ ê¸°ë°˜ ì‚¬ìš©ì ë¬¸ì„œ**

```markdown
# ì‚¬ìš©ì ê°€ì´ë“œ
## Crypto AutoTrade System User Guide

### ì‹œì‘í•˜ê¸°

#### 1. ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­
- Python 3.9 ì´ìƒ
- 8GB ì´ìƒ RAM
- ì•ˆì •ì ì¸ ì¸í„°ë„· ì—°ê²°
- ì§€ì› ê±°ë˜ì†Œ ê³„ì • (Binance, Bybit)

#### 2. ì„¤ì¹˜ ë° ì„¤ì •

**ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì¹˜:**
```bash
# 1. ë¦´ë¦¬ìŠ¤ í˜ì´ì§€ì—ì„œ ìµœì‹  ë²„ì „ ë‹¤ìš´ë¡œë“œ
wget https://github.com/crypto-autotrade/releases/latest/crypto-autotrade-desktop.zip

# 2. ì••ì¶• í•´ì œ
unzip crypto-autotrade-desktop.zip

# 3. ì‹¤í–‰
cd crypto-autotrade-desktop
./crypto-autotrade
```

**ì›¹ ì¸í„°í˜ì´ìŠ¤ ì ‘ì†:**
1. ë¸Œë¼ìš°ì €ì—ì„œ `http://localhost:5000` ì ‘ì†
2. ê³„ì • ìƒì„± ë˜ëŠ” ë¡œê·¸ì¸
3. API í‚¤ ì„¤ì •

#### 3. ê¸°ë³¸ ì„¤ì •

**API í‚¤ ì„¤ì •:**
1. ê±°ë˜ì†Œì—ì„œ API í‚¤ ìƒì„±
   - Binance: ì„ ë¬¼ ê±°ë˜ ê¶Œí•œ í•„ìš”
   - Bybit: ì„ ë¬¼ ê±°ë˜ ê¶Œí•œ í•„ìš”
2. ì‹œìŠ¤í…œì— API í‚¤ ë“±ë¡
3. ì—°ê²° í…ŒìŠ¤íŠ¸ ìˆ˜í–‰

**ë³´ì•ˆ ì„¤ì •:**
1. ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (8ì ì´ìƒ, ì˜ë¬¸+ìˆ«ì+íŠ¹ìˆ˜ë¬¸ì)
2. 2ë‹¨ê³„ ì¸ì¦ í™œì„±í™” (ê¶Œì¥)
3. IP í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì„¤ì • (ì„ íƒì‚¬í•­)

### ê±°ë˜ ì„¤ì •

#### 1. ì§„ì… ì¡°ê±´ ì„¤ì •

**ì´ë™í‰ê·  ì¡°ê±´:**
- **ì¡°ê±´ íƒ€ì… ì„ íƒ:**
  - `open_above_ma_buy`: ì‹œê°€ê°€ ì´ë™í‰ê·  ìœ„ì—ì„œ ë§¤ìˆ˜
  - `close_above_ma_buy`: ì¢…ê°€ê°€ ì´ë™í‰ê·  ìœ„ì—ì„œ ë§¤ìˆ˜
  - `open_below_ma_sell`: ì‹œê°€ê°€ ì´ë™í‰ê·  ì•„ë˜ì—ì„œ ë§¤ë„
  - `close_below_ma_sell`: ì¢…ê°€ê°€ ì´ë™í‰ê·  ì•„ë˜ì—ì„œ ë§¤ë„

- **ì„¤ì • ë°©ë²•:**
  1. "ì§„ì… ì„¤ì •" íƒ­ ì„ íƒ
  2. "ì´ë™í‰ê·  ì¡°ê±´" í™œì„±í™”
  3. ì¡°ê±´ íƒ€ì… ì„ íƒ
  4. ì‚¬ìš©ì ì •ì˜ ì¡°ê±´ ì¶”ê°€ (ì„ íƒì‚¬í•­)

**Price Channel ì¡°ê±´:**
- **ì§€í‘œ íƒ€ì…:**
  - Donchian Channel
  - Bollinger Bands
  - Keltner Channel

- **ì„¤ì • ë°©ë²•:**
  1. "Price Channel ì¡°ê±´" í™œì„±í™”
  2. ì§€í‘œ íƒ€ì… ì„ íƒ
  3. ê¸°ê°„ ì„¤ì • (ê¸°ë³¸ê°’: 20)
  4. ìƒ/í•˜ë‹¨ì„  ëŒíŒŒ ì¡°ê±´ ì„¤ì •

#### 2. ì²­ì‚° ì¡°ê±´ ì„¤ì •

**PCS (Price Channel System) ì²­ì‚°:**
- **ë‹¨ê³„ë³„ ì²­ì‚°:**
  - 1ë‹¨ê³„: ìƒë‹¨ì„  ìƒìŠ¹ + ì–‘ë´‰ í›„ ìŒë´‰ ë§ˆê°
  - 2ë‹¨ê³„: ìƒë‹¨ì„  í•˜ë½ + ìŒë´‰ ë§ˆê°
  - 3ë‹¨ê³„: í•˜ë‹¨ì„  í„°ì¹˜

- **ì„¤ì • ë°©ë²•:**
  1. "ì²­ì‚° ì„¤ì •" íƒ­ ì„ íƒ
  2. "PCS ì²­ì‚°" í™œì„±í™”
  3. ì²­ì‚° ë‹¨ê³„ ì„ íƒ (1,2,3 ë˜ëŠ” ì¡°í•©)
  4. ê° ë‹¨ê³„ë³„ ì²­ì‚° ë¹„ìœ¨ ì„¤ì •

**íŠ¸ë ˆì¼ë§ ìŠ¤í†±:**
- **ë™ì  ì†ì ˆê°€ ì¡°ì •:**
  - ìˆ˜ìµ ë°œìƒ ì‹œ ì†ì ˆê°€ë¥¼ ìë™ìœ¼ë¡œ ìƒí–¥ ì¡°ì •
  - ìµœëŒ€ ìˆ˜ìµ ë³´í˜¸ ê¸°ëŠ¥

- **ì„¤ì • ë°©ë²•:**
  1. "íŠ¸ë ˆì¼ë§ ìŠ¤í†±" í™œì„±í™”
  2. íŠ¸ë ˆì¼ë§ ê±°ë¦¬ ì„¤ì • (%)
  3. ìµœì†Œ ìˆ˜ìµë¥  ì„¤ì •

#### 3. ë¦¬ìŠ¤í¬ ê´€ë¦¬

**í¬ì§€ì…˜ í¬ê¸° ê´€ë¦¬:**
- ê³„ì¢Œ ì”ê³  ëŒ€ë¹„ ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° ì œí•œ
- ì‹¬ë³¼ë³„ ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì œí•œ
- ì¼ì¼ ìµœëŒ€ ì†ì‹¤ í•œë„ ì„¤ì •

**ì†ì ˆë§¤ ì„¤ì •:**
- ê³ ì • ì†ì ˆë§¤: ì§„ì…ê°€ ëŒ€ë¹„ ê³ ì • ë¹„ìœ¨
- ë™ì  ì†ì ˆë§¤: ë³€ë™ì„± ê¸°ë°˜ ìë™ ì¡°ì •
- ì‹œê°„ ê¸°ë°˜ ì†ì ˆë§¤: ì¼ì • ì‹œê°„ í›„ ìë™ ì²­ì‚°

### ëª¨ë‹ˆí„°ë§ ë° ê´€ë¦¬

#### 1. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

**ëŒ€ì‹œë³´ë“œ í™”ë©´:**
- í˜„ì¬ í¬ì§€ì…˜ í˜„í™©
- ì‹¤ì‹œê°„ ì†ìµ í˜„í™©
- ê±°ë˜ ì‹ í˜¸ ë°œìƒ ìƒí™©
- ì‹œìŠ¤í…œ ìƒíƒœ ëª¨ë‹ˆí„°ë§

**ì•Œë¦¼ ì„¤ì •:**
- í¬ì§€ì…˜ ê°œì„¤/ì²­ì‚° ì•Œë¦¼
- ì†ìµ ì„ê³„ê°’ ì•Œë¦¼
- ì‹œìŠ¤í…œ ì˜¤ë¥˜ ì•Œë¦¼
- ì´ë©”ì¼/SMS/í…”ë ˆê·¸ë¨ ì—°ë™

#### 2. ê±°ë˜ ë‚´ì—­ ê´€ë¦¬

**ê±°ë˜ ë¡œê·¸:**
- ëª¨ë“  ê±°ë˜ ë‚´ì—­ ìë™ ê¸°ë¡
- ì§„ì…/ì²­ì‚° ì‚¬ìœ  ìƒì„¸ ê¸°ë¡
- ìˆ˜ìµë¥  í†µê³„ ë° ë¶„ì„
- CSV/Excel ë‚´ë³´ë‚´ê¸° ê¸°ëŠ¥

**ì„±ê³¼ ë¶„ì„:**
- ì¼/ì£¼/ì›”ë³„ ìˆ˜ìµë¥  ë¶„ì„
- ìŠ¹ë¥  ë° í‰ê·  ìˆ˜ìµ/ì†ì‹¤ ë¹„ìœ¨
- ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´ ë¶„ì„
- ìƒ¤í”„ ë¹„ìœ¨ ë“± ìœ„í—˜ ì¡°ì • ìˆ˜ìµë¥ 

### ê³ ê¸‰ ê¸°ëŠ¥

#### 1. ì‚¬ìš©ì ì •ì˜ ì¡°ê±´

**ì»¤ìŠ¤í…€ ì§„ì… ì¡°ê±´:**
```python
# ì˜ˆì‹œ: RSI ê¸°ë°˜ ì§„ì… ì¡°ê±´
def custom_rsi_condition(market_data):
    rsi = calculate_rsi(market_data.close_prices, 14)
    
    if rsi < 30:  # ê³¼ë§¤ë„
        return Signal("BUY", confidence=0.8)
    elif rsi > 70:  # ê³¼ë§¤ìˆ˜
        return Signal("SELL", confidence=0.8)
    
    return None
```

**ë°±í…ŒìŠ¤íŒ…:**
- ê³¼ê±° ë°ì´í„°ë¥¼ ì´ìš©í•œ ì „ëµ ê²€ì¦
- ë‹¤ì–‘í•œ ì‹œì¥ ìƒí™©ì—ì„œì˜ ì„±ê³¼ ë¶„ì„
- ìµœì  íŒŒë¼ë¯¸í„° íƒìƒ‰
- ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜

#### 2. API ì—°ë™

**REST API ì‚¬ìš©:**
```python
import requests

# í¬ì§€ì…˜ ì¡°íšŒ
response = requests.get(
    'http://localhost:5000/api/trading/positions',
    headers={'Authorization': 'Bearer YOUR_TOKEN'}
)

positions = response.json()['data']
```

**WebSocket ì‹¤ì‹œê°„ ë°ì´í„°:**
```javascript
const socket = io('http://localhost:5000');

socket.on('position_update', (data) => {
    console.log('Position updated:', data);
});

socket.on('trading_signal', (data) => {
    console.log('New signal:', data);
});
```

### ë¬¸ì œ í•´ê²°

#### 1. ì¼ë°˜ì ì¸ ë¬¸ì œ

**ì—°ê²° ì˜¤ë¥˜:**
- API í‚¤ ìœ íš¨ì„± í™•ì¸
- ë„¤íŠ¸ì›Œí¬ ì—°ê²° ìƒíƒœ ì ê²€
- ë°©í™”ë²½ ì„¤ì • í™•ì¸

**ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨:**
- ê³„ì¢Œ ì”ê³  í™•ì¸
- ê±°ë˜ì†Œ ì ê²€ ìƒíƒœ í™•ì¸
- ì£¼ë¬¸ íŒŒë¼ë¯¸í„° ê²€ì¦

**ì„±ëŠ¥ ì €í•˜:**
- ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ í™•ì¸
- ë¡œê·¸ íŒŒì¼ í¬ê¸° ê´€ë¦¬
- ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”

#### 2. ë¡œê·¸ ë¶„ì„

**ë¡œê·¸ íŒŒì¼ ìœ„ì¹˜:**
- ë°ìŠ¤í¬í†±: `./logs/trading.log`
- ì›¹: `/var/log/crypto-autotrade/`

**ì£¼ìš” ë¡œê·¸ ë ˆë²¨:**
- INFO: ì¼ë°˜ì ì¸ ê±°ë˜ í™œë™
- WARNING: ì£¼ì˜ê°€ í•„ìš”í•œ ìƒí™©
- ERROR: ì˜¤ë¥˜ ë°œìƒ
- CRITICAL: ì‹œìŠ¤í…œ ì¤‘ë‹¨ ìˆ˜ì¤€ ì˜¤ë¥˜

### ì§€ì› ë° ì»¤ë®¤ë‹ˆí‹°

#### 1. ê¸°ìˆ  ì§€ì›
- ì´ë©”ì¼: support@crypto-autotrade.com
- ë””ìŠ¤ì½”ë“œ: https://discord.gg/crypto-autotrade
- GitHub Issues: https://github.com/crypto-autotrade/issues

#### 2. ë¬¸ì„œ ë° ìë£Œ
- API ë¬¸ì„œ: http://localhost:5000/docs/
- ê°œë°œì ê°€ì´ë“œ: https://docs.crypto-autotrade.com/
- ë¹„ë””ì˜¤ íŠœí† ë¦¬ì–¼: https://youtube.com/crypto-autotrade

#### 3. ì»¤ë®¤ë‹ˆí‹°
- ì‚¬ìš©ì í¬ëŸ¼: https://forum.crypto-autotrade.com/
- í…”ë ˆê·¸ë¨ ì±„ë„: https://t.me/crypto_autotrade
- ë ˆë”§ ì»¤ë®¤ë‹ˆí‹°: https://reddit.com/r/crypto_autotrade
```

---

## ğŸ¯ 9. ê²°ë¡  ë° ë‹¤ìŒ ë‹¨ê³„

### 9.1 ë¬¸ì„œ í™œìš© ë°©ë²•

ë³¸ í†µí•© ê°€ì´ë“œëŠ” Claude ì„œë¸Œì—ì´ì „íŠ¸ë“¤ì´ ì²´ê³„ì ì´ê³  ì¼ê´€ëœ ê°œë°œì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì¢…í•©ì ì¸ ì°¸ì¡° ë¬¸ì„œì…ë‹ˆë‹¤. ê° ì—ì´ì „íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì´ í™œìš©í•´ì•¼ í•©ë‹ˆë‹¤:

**Claude Core (ê±°ë˜ ì—”ì§„ ë‹´ë‹¹)**
- í´ë¦°ì½”ë“œ ê°€ì´ë“œë¼ì¸ì˜ Core ëª¨ë“ˆ í‘œì¤€ì„ ì—„ê²©íˆ ì¤€ìˆ˜
- SOLID ì›ì¹™ê³¼ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì›ì¹™ ì ìš©
- ì„±ëŠ¥ê³¼ ì•ˆì •ì„±ì„ ìµœìš°ì„ ìœ¼ë¡œ í•˜ëŠ” ì½”ë“œ ì‘ì„±
- í¬ê´„ì ì¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ë° í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±

**Claude GUI (ë°ìŠ¤í¬í†± ì¸í„°í˜ì´ìŠ¤ ë‹´ë‹¹)**
- ì‚¬ìš©ì ê²½í—˜ ì¤‘ì‹¬ì˜ ë°˜ì‘í˜• ì¸í„°í˜ì´ìŠ¤ ê°œë°œ
- ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ì™€ ë¹„ë™ê¸° ì²˜ë¦¬ ì ìš©
- ì‹¤ì‹œê°„ ë°ì´í„° í‘œì‹œ ë° ì‚¬ìš©ì í”¼ë“œë°± êµ¬í˜„
- ì ‘ê·¼ì„±ê³¼ ì‚¬ìš©ì„±ì„ ê³ ë ¤í•œ UI/UX ì„¤ê³„

**Claude Web (ì›¹ API ë° ì¸í„°í˜ì´ìŠ¤ ë‹´ë‹¹)**
- RESTful API ì„¤ê³„ ì›ì¹™ ì¤€ìˆ˜
- ë³´ì•ˆê³¼ ì„±ëŠ¥ì„ ì¤‘ì‹œí•˜ëŠ” ì›¹ ì„œë¹„ìŠ¤ ê°œë°œ
- WebSocketì„ í†µí•œ ì‹¤ì‹œê°„ í†µì‹  êµ¬í˜„
- í™•ì¥ ê°€ëŠ¥í•œ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ ì ìš©

**Claude Data (ë°ì´í„° ê´€ë¦¬ ë‹´ë‹¹)**
- ë°ì´í„° ë¬´ê²°ì„±ê³¼ ì¼ê´€ì„± ë³´ì¥
- ì„±ëŠ¥ ìµœì í™”ëœ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„
- ë°±ì—… ë° ë³µêµ¬ ì‹œìŠ¤í…œ êµ¬ì¶•
- ë°ì´í„° ë¶„ì„ ë° ë¦¬í¬íŒ… ë„êµ¬ ê°œë°œ

**Claude Test (í…ŒìŠ¤íŠ¸ ë° í’ˆì§ˆ ê´€ë¦¬ ë‹´ë‹¹)**
- í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ êµ¬ì¡° êµ¬í˜„
- ìë™í™”ëœ í’ˆì§ˆ ê²€ì¦ í”„ë¡œì„¸ìŠ¤ êµ¬ì¶•
- ì§€ì†ì  í†µí•©/ë°°í¬ íŒŒì´í”„ë¼ì¸ ê´€ë¦¬
- ì½”ë“œ í’ˆì§ˆ ë©”íŠ¸ë¦­ ëª¨ë‹ˆí„°ë§

### 9.2 ì§€ì†ì  ê°œì„  í”„ë¡œì„¸ìŠ¤

**ë¬¸ì„œ ì—…ë°ì´íŠ¸ ì£¼ê¸°**
- ë§¤ ìŠ¤í”„ë¦°íŠ¸ ì¢…ë£Œ ì‹œ ë¬¸ì„œ ê²€í†  ë° ì—…ë°ì´íŠ¸
- ìƒˆë¡œìš´ ê¸°ìˆ  ë„ì… ì‹œ ê°€ì´ë“œë¼ì¸ ì¶”ê°€
- íŒ€ í”¼ë“œë°±ì„ ë°˜ì˜í•œ í”„ë¡œì„¸ìŠ¤ ê°œì„ 
- ë²„ì „ ê´€ë¦¬ë¥¼ í†µí•œ ë³€ê²½ ì‚¬í•­ ì¶”ì 

**í’ˆì§ˆ ë©”íŠ¸ë¦­ ì¶”ì **
- ì½”ë“œ ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ ìœ ì§€
- ì½”ë“œ ë³µì¡ë„ ì§€ìˆ˜ ëª¨ë‹ˆí„°ë§
- ë²„ê·¸ ë°œìƒë¥  ë° í•´ê²° ì‹œê°„ ì¶”ì 
- ì‚¬ìš©ì ë§Œì¡±ë„ ë° ì‹œìŠ¤í…œ ì•ˆì •ì„± ì¸¡ì •

**ê¸°ìˆ  ë¶€ì±„ ê´€ë¦¬**
- ì •ê¸°ì ì¸ ë¦¬íŒ©í† ë§ ê³„íš ìˆ˜ë¦½
- ë ˆê±°ì‹œ ì½”ë“œ í˜„ëŒ€í™” ë¡œë“œë§µ
- ì„±ëŠ¥ ë³‘ëª© ì§€ì  ì‹ë³„ ë° ê°œì„ 
- ë³´ì•ˆ ì·¨ì•½ì  ì •ê¸° ì ê²€ ë° íŒ¨ì¹˜

### 9.3 ì„±ê³µ ì§€í‘œ

**ê°œë°œ íš¨ìœ¨ì„±**
- ê¸°ëŠ¥ ê°œë°œ ì†ë„ í–¥ìƒ (ìŠ¤í”„ë¦°íŠ¸ë‹¹ ì™„ë£Œ ìŠ¤í† ë¦¬ í¬ì¸íŠ¸)
- ë²„ê·¸ ë°œìƒë¥  ê°ì†Œ (ë¦´ë¦¬ìŠ¤ë‹¹ ë²„ê·¸ ìˆ˜)
- ì½”ë“œ ë¦¬ë·° ì‹œê°„ ë‹¨ì¶•
- ë°°í¬ ì£¼ê¸° ë‹¨ì¶• ë° ì•ˆì •ì„± í–¥ìƒ

**ì½”ë“œ í’ˆì§ˆ**
- ì½”ë“œ ì¤‘ë³µë¥  5% ì´í•˜ ìœ ì§€
- ìˆœí™˜ ë³µì¡ë„ 10 ì´í•˜ ìœ ì§€
- í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ 80% ì´ìƒ ë‹¬ì„±
- ì •ì  ë¶„ì„ ë„êµ¬ ê²½ê³  0ê°œ ìœ ì§€

**íŒ€ í˜‘ì—…**
- ì—ì´ì „íŠ¸ ê°„ ì˜ì¡´ì„± ì¶©ëŒ ìµœì†Œí™”
- ì¸í„°í˜ì´ìŠ¤ ë³€ê²½ìœ¼ë¡œ ì¸í•œ ì˜í–¥ ë²”ìœ„ ì œí•œ
- ì§€ì‹ ê³µìœ  ë° ë¬¸ì„œí™” ìˆ˜ì¤€ í–¥ìƒ
- ì½”ë“œ ë¦¬ë·° í’ˆì§ˆ ë° ì°¸ì—¬ë„ í–¥ìƒ

ì´ í†µí•© ê°€ì´ë“œë¥¼ í†µí•´ ê° Claude ì„œë¸Œì—ì´ì „íŠ¸ê°€ ì „ë¬¸ì„±ì„ ë°œíœ˜í•˜ë©´ì„œë„ ì „ì²´ ì‹œìŠ¤í…œì˜ ì¼ê´€ì„±ê³¼ í’ˆì§ˆì„ ë³´ì¥í•  ìˆ˜ ìˆëŠ” ì²´ê³„ì ì¸ ê°œë°œ í™˜ê²½ì´ êµ¬ì¶•ë  ê²ƒì…ë‹ˆë‹¤. ì§€ì†ì ì¸ ê°œì„ ê³¼ í”¼ë“œë°±ì„ í†µí•´ ë”ìš± íš¨ìœ¨ì ì´ê³  ì•ˆì •ì ì¸ ê°œë°œ í”„ë¡œì„¸ìŠ¤ë¡œ ë°œì „ì‹œì¼œ ë‚˜ê°€ì‹œê¸° ë°”ëë‹ˆë‹¤.

---

**ë¬¸ì„œ ë²„ì „**: 1.0  
**ìµœì¢… ì—…ë°ì´íŠ¸**: 2025ë…„ 1ì›” 9ì¼  
**ë‹¤ìŒ ê²€í†  ì˜ˆì •ì¼**: 2025ë…„ 2ì›” 9ì¼

